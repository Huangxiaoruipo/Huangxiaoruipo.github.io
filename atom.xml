<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>KITOHUANG</title>
  
  <subtitle>每日一言</subtitle>
  <link href="http://huangxiaoruipo.github.io/atom.xml" rel="self"/>
  
  <link href="http://huangxiaoruipo.github.io/"/>
  <updated>2022-04-14T09:14:15.487Z</updated>
  <id>http://huangxiaoruipo.github.io/</id>
  
  <author>
    <name>KITOHUANG</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Hello World</title>
    <link href="http://huangxiaoruipo.github.io/2022/11/04/hello-world/"/>
    <id>http://huangxiaoruipo.github.io/2022/11/04/hello-world/</id>
    <published>2022-11-04T15:00:35.803Z</published>
    <updated>2022-04-14T09:14:15.487Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>正则表达式（其一）</title>
    <link href="http://huangxiaoruipo.github.io/2022/05/07/zheng-ze-biao-da-shi/"/>
    <id>http://huangxiaoruipo.github.io/2022/05/07/zheng-ze-biao-da-shi/</id>
    <published>2022-05-07T07:19:15.000Z</published>
    <updated>2022-05-07T10:24:58.803Z</updated>
    
    <content type="html"><![CDATA[<h3 id="python的正则表达式"><a href="#python的正则表达式" class="headerlink" title="python的正则表达式"></a>python的正则表达式</h3><p>python的re模块提供perl风格的的正则表达式，这里简单写一下正则表达的处理函数。</p><h3 id="re-match"><a href="#re-match" class="headerlink" title="re.match"></a>re.match</h3><pre class="line-numbers language-none"><code class="language-none">re.match(pattern, string, flags&#x3D;0)#pattern:匹配表达式#string：匹配字符串flags：控制表达式的匹配方式<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>re.match匹配成功会返回一个匹配对象，否则返回None</p><pre class="line-numbers language-none"><code class="language-none">import reexp1 &#x3D; re.match(&#39;www&#39;, &#39;https:&#x2F;&#x2F;www.bilibili.com&#x2F;video&#x2F;BV1es41127PE?p&#x3D;14&#39;)#起始位置匹配exp2 &#x3D; re.match(&#39;www&#39;, &#39;www.bilibili.com&#x2F;video&#x2F;BV1es41127PE?p&#x3D;14&#39;).span()#非起始位置匹配exp3 &#x3D; re.match(&#39;p&#x3D;14&#39;, &#39;www.bilibili.com&#x2F;video&#x2F;BV1es41127PE?p&#x3D;14&#39;)print(exp2)print(exp3)-------------(0, 3)None<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们可以使用 group(num) 或 groups() 匹配对象函数来获取匹配表达式</p><p> group(num)匹配的整个表达式的字符串，group() 可以一次输入多个组号，在这种情况下它将返回一个包含那些组所对应值的元组。</p><p> groups()  返回一个包含所有小组字符串的元组，从 1 到 所含的小组号</p><pre class="line-numbers language-none"><code class="language-none">import reline &#x3D; &#39;Cats are smarter than dogs&#39;matchObject &#x3D; re.match(r&#39;(.*) are (.*?) .*&#39;, line, re.M | re.I)#r表示忽略反斜杠，不视作转移符号#(.*)是第一个分组，匹配换行符之外所有的字符串，后面接的是&#96; are &#96;表示第一组匹配到&#96; are &#96;之前结束#&#96; are &#96;后面是第二个(.*?)分组，表示从&#96; are &#96;后面开始匹配，?是非贪婪模式，匹配最短字符#第三个.*是表示后面的所有字符，不在分组内if matchObject:    print(f&#39;matchObject.group():&#123;matchObject.group()&#125;&#39;)    #group()等于group(0)，表示匹配到的完整文本    print(f&#39;matchObject.group(1):&#123;matchObject.group(1)&#125;&#39;)    #group(1)，表示匹配到的第一个组    print(f&#39;matchObject.group(2):&#123;matchObject.group(2)&#125;&#39;)    #group(2)，表示匹配到的第二个组    print(f&#39;matchObject.groups():&#123;matchObject.groups()&#125;&#39;)    #groups()，表示匹配到的所有组    #没有group(3)，因为最后一个&#96;.*&#96;不是组else:    print(&#39;no match&#39;)----------------------matchObject.group():Cats are smarter than dogsmatchObject.group(1):CatsmatchObject.group(2):smartermatchObject.groups():(&#39;Cats&#39;, &#39;smarter&#39;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="re-match和re-search区别"><a href="#re-match和re-search区别" class="headerlink" title="re.match和re.search区别"></a>re.match和re.search区别</h3><pre class="line-numbers language-none"><code class="language-none">import reline &#x3D; &#39;Cats are smarter than dogs&#39;matchObject &#x3D; re.match(r&#39;(.*) are (.*?) .*&#39;, line, re.M | re.I)searchObject &#x3D; re.search(r&#39;(.*) are (.*?) .*&#39;, line, re.M | re.I)matchObject_mod &#x3D; re.match(r&#39;dogs&#39;, line, re.M | re.I)searchObject_mod &#x3D; re.search(r&#39;dogs&#39;, line, re.M | re.I)if matchObject:    print(f&#39;matchObject.group(）:&#123;matchObject.group()&#125;&#39;)    print(f&#39;matchObject.group(1）:&#123;matchObject.group(1)&#125;&#39;)    print(f&#39;matchObject.group(2）:&#123;matchObject.group(2)&#125;&#39;)    print(f&#39;matchObject.groups(）:&#123;matchObject.groups()&#125;&#39;)else:    print(&#39;no match&#39;)if searchObject:    print(f&#39;searchObject.group(）:&#123;searchObject.group()&#125;&#39;)    print(f&#39;searchObject.group(1）:&#123;searchObject.group(1)&#125;&#39;)    print(f&#39;searchObject.group(2）:&#123;searchObject.group(2)&#125;&#39;)    print(f&#39;searchObject.groups(）:&#123;searchObject.groups()&#125;&#39;)else:    print(&#39;no match&#39;)if matchObject_mod:    print(f&#39;matchObject_mod:&#123;matchObject_mod&#125;&#39;)    print(f&#39;matchObject_mod:&#123;matchObject_mod.group()&#125;&#39;)else:    print(&#39;no match&#39;)if searchObject_mod:    print(f&#39;searchObject_mod:&#123;searchObject_mod&#125;&#39;)    print(f&#39;searchObject_mod:&#123;searchObject_mod.group()&#125;&#39;)else:    print(&#39;no match&#39;)-------------------------matchObject.group(）:Cats are smarter than dogsmatchObject.group(1）:CatsmatchObject.group(2）:smartermatchObject.groups(）:(&#39;Cats&#39;, &#39;smarter&#39;)searchObject.group(）:Cats are smarter than dogssearchObject.group(1）:CatssearchObject.group(2）:smartersearchObject.groups(）:(&#39;Cats&#39;, &#39;smarter&#39;)no matchsearchObject_mod:&lt;re.Match object; span&#x3D;(22, 26), match&#x3D;&#39;dogs&#39;&gt;searchObject_mod:dogs<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以发现，re.match和re.search区别在于查询的条件不一样，re.match正则匹配到的字符串开始的内容不符，则会匹配失败，返回None；re.search区别则会匹配整个字符串，返回第一个匹配到的字符位置。</p><h3 id="检索和替换"><a href="#检索和替换" class="headerlink" title="检索和替换"></a>检索和替换</h3><pre class="line-numbers language-none"><code class="language-none">re.sub(pattern, repl, string, count&#x3D;0, flags&#x3D;0)#pattern : 正则中的模式字符串。#repl : 替换的字符串，也可为一个函数。#string : 要被查找替换的原始字符串。#count : 模式匹配后替换的最大次数，默认 0 表示替换所有的匹配。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>实例</p><pre class="line-numbers language-none"><code class="language-none">date &#x3D; &#39;2020-05-07    # 这是今天的日期&#39;# 删除后面的注释this_date &#x3D; re.sub(r&#39;\s*#.*$&#39;,&quot;&quot;,date)#匹配任意空格到 # 字符，#字符后面任意字符直至字符串末尾（$表示匹配字符串末尾）this_num &#x3D; re.sub(r&#39;\D&#39;,&quot;&quot;,date)#匹配所有非数字字符（\D表示所有非数字字符）print(this_date)print(this_num)---------------2020-05-0720200507<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>repl参数是一个函数</p><p>我们可以将匹配的字符串内容都用函数处理</p><p>实例：将匹配到的数字乘以2</p><pre class="line-numbers language-none"><code class="language-none">def double(matched):    value &#x3D; int(matched.group(&#39;value&#39;))    return str(value * 2)s &#x3D; &#39;A23G4HFD567&#39;print(re.sub(&#39;(?P&lt;value&gt;\d+)&#39;, double, s))#?P&lt;value&gt;的意思是命名一个为value的组，\d+是匹配条件，整个?P&lt;value&gt;\d+的意思是命名一个为value的组，匹配规则符合\d+-------------------A46G8HFD1134<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/2022/05/07/zheng-ze-biao-da-shi/image-20220507182017074.png" alt="匹配结果"></p><p>可以看到第一次匹配到的数字23被传递到 double函数里面，用group（）方法将23取出转为整型后返回2倍的23，和输出结果一致。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;python的正则表达式&quot;&gt;&lt;a href=&quot;#python的正则表达式&quot; class=&quot;headerlink&quot; title=&quot;python的正则表达式&quot;&gt;&lt;/a&gt;python的正则表达式&lt;/h3&gt;&lt;p&gt;python的re模块提供perl风格的的正则表达式，这里简</summary>
      
    
    
    
    <category term="Python" scheme="http://huangxiaoruipo.github.io/categories/Python/"/>
    
    
    <category term="正则表达" scheme="http://huangxiaoruipo.github.io/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE/"/>
    
  </entry>
  
  <entry>
    <title>遍历文件夹、匹配文件、打开切片修改文件案例</title>
    <link href="http://huangxiaoruipo.github.io/2022/05/03/bian-li-wen-jian-jia-pi-pei-wen-jian-da-kai-qie-pian-xiu-gai-wen-jian-an-li/"/>
    <id>http://huangxiaoruipo.github.io/2022/05/03/bian-li-wen-jian-jia-pi-pei-wen-jian-da-kai-qie-pian-xiu-gai-wen-jian-an-li/</id>
    <published>2022-05-03T14:10:41.000Z</published>
    <updated>2022-05-03T14:29:45.433Z</updated>
    
    <content type="html"><![CDATA[<pre class="line-numbers language-none"><code class="language-none">import osimport re# 遍历文件夹下的指定后缀文件def get_file_list(base_dir&#x3D;&#39;.&#39;, target_ext&#x3D;&#39;&#39;) -&gt; list:    fname_list &#x3D; []    for fname in os.listdir(base_dir):        # 遍历指定目录        path &#x3D; os.path.join(base_dir, fname)        # 把文件名和所在目录名连接起来        if os.path.isfile(path):            # 判断是否是“文件”类型            fname_main, fname_ext &#x3D; os.path.splitext(fname)            # 把文件名和后缀切分开            if fname_ext &#x3D;&#x3D; target_ext or target_ext &#x3D;&#x3D; &#39;&#39;:                # 判断是否指定的后缀名                fname_list.append(path)                # 将符合条件的文件全路径名加入列表        # elif os.path.isdir(path):        # # 判断是否文件夹类型        #     temp_list &#x3D; get_file_list(path, target_ext)        # # 递归调用查找子目录        #     fname_list &#x3D; fname_list + temp_list        # # 将递归调用返回的文件名列表合并        # else:        #     pass    return fname_list  # 返回查到的文件名列表def replace_file(fname_list, replce_list&#x3D;&#39;.&#39;, save_dir&#x3D;&#39;.&#39;):    with open(replce_list) as f1:        # 打开一个包含班组制作信息的文件        for each_line in f1:            # 做分割处理            (part, part_ban, quanty) &#x3D; each_line.strip(&#39;\n&#39;).split(&#39;+&#39;, 2)            for file in fname_list:                # 遍历文件下所有的文件                with open(file) as f2:                    NC_vaul &#x3D; f2.readlines()                    # 判断文件名称是否和清单一致                if part &#x3D;&#x3D; NC_vaul[1][:len(NC_vaul[1]) - 1]:                    # 替换列表内容                    NC_vaul[1] &#x3D; part_ban + &#39;\n&#39;                    NC_vaul[7] &#x3D; quanty + &#39;\n&#39;                    # 将readliness内容储存到文本文件                    with open(save_dir + part_ban[3:], &quot;w&quot;) as f3:                        f3.writelines(NC_vaul)if __name__ &#x3D;&#x3D; &quot;__main__&quot;:    file_list &#x3D; get_file_list(r&#39;.&#x2F;txt&#x2F;&#39;, &#39;.nc1&#39;)    replace_file(file_list, replce_list&#x3D;&#39;.&#x2F;txt&#x2F;班组—制作数量.txt&#39;, save_dir&#x3D;&#39;.&#x2F;txt&#x2F;&#39;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>两年前刚到公司上班的时候写的脚本，因为公司管理模式没细化的原因，粗放的给每个加工零件。结果有一天外协出去的图纸因为零件数量问题要我去一个一个修改，几千图纸一个一个打开修改（痛苦面具），每出一次图纸我都要去BIM里面修改一次零件数据也太麻烦了，百度了数控文件的类型是德标的（大概），然后对比了几组不同的图纸，发现了每组零件名称和数量所在的位置。</p><p>通过人工添加制作加工清单，然后将本批次需要加工的所有数控遍历，匹配名称后，用readliness读取出来（readline读取单行，反正我修改不了），readliness返回的是一个列表，我们可以通过切片的方式去修改固定位置的数据。</p><p>最后新建一个文件将它保存起来，不在原地保存。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;pre class=&quot;line-numbers language-none&quot;&gt;&lt;code class=&quot;language-none&quot;&gt;import os
import re


# 遍历文件夹下的指定后缀文件
def get_file_list(base_dir&amp;#x3D;&amp;#</summary>
      
    
    
    
    <category term="Python" scheme="http://huangxiaoruipo.github.io/categories/Python/"/>
    
    
    <category term="OS模块" scheme="http://huangxiaoruipo.github.io/tags/OS%E6%A8%A1%E5%9D%97/"/>
    
    <category term="遍历文件" scheme="http://huangxiaoruipo.github.io/tags/%E9%81%8D%E5%8E%86%E6%96%87%E4%BB%B6/"/>
    
    <category term="指定后缀" scheme="http://huangxiaoruipo.github.io/tags/%E6%8C%87%E5%AE%9A%E5%90%8E%E7%BC%80/"/>
    
    <category term="持久化储存数据" scheme="http://huangxiaoruipo.github.io/tags/%E6%8C%81%E4%B9%85%E5%8C%96%E5%82%A8%E5%AD%98%E6%95%B0%E6%8D%AE/"/>
    
    <category term="列表切片" scheme="http://huangxiaoruipo.github.io/tags/%E5%88%97%E8%A1%A8%E5%88%87%E7%89%87/"/>
    
  </entry>
  
  <entry>
    <title>Python pandas note</title>
    <link href="http://huangxiaoruipo.github.io/2022/04/30/python-pandas-note/"/>
    <id>http://huangxiaoruipo.github.io/2022/04/30/python-pandas-note/</id>
    <published>2022-04-30T08:36:31.000Z</published>
    <updated>2022-05-02T04:07:14.833Z</updated>
    
    <content type="html"><![CDATA[<h3 id="pandas基本功能"><a href="#pandas基本功能" class="headerlink" title="pandas基本功能"></a>pandas基本功能</h3><p>使用的是tekla13.0版本套料工具生成工程时，形成的<code>report</code>数据，名字是<code>myflie.csv</code></p><h4 id="读取数据"><a href="#读取数据" class="headerlink" title="读取数据"></a>读取数据</h4><p>pandas采用read_csv方法读取文件时会出现编码错误，在代码首部加上说明，读取时使用<code>gbk</code>的编码方式，全部代码如下：</p><pre class="line-numbers language-none"><code class="language-none"># -- coding : utf-8 --# coding: utf-8import pandas as pdimport openpyxlimport numpy as npimport timeimport xlrddata &#x3D; pd.read_csv(&#39;myfile.csv&#39;, header&#x3D;None, sep&#x3D;&#39;,&#39;, encoding&#x3D;&#39;gbk&#39;)print(data)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/2022/04/30/python-pandas-note/image-20220501093337810.png" alt="读取结果"></p><p>可以看到一共在<code>myfile.csv</code>内读取到了7行13列的数据，第一行是标题行，第三列到第十列被压缩起来了，我们无法看到数据的全貌，提供方法去展示数据：</p><p>在print之前添加一个<code>pd.set_option(&#39;display.max_columns&#39;, None)</code>的属性，顺便的把<code>header</code>设置为0，把第一行做为列索引（<code>index_col=0</code>可以设置列索引，<code>usecols=[1,2,3]</code>用来选定对应的列数）。</p><pre class="line-numbers language-none"><code class="language-none">import pandas as pdimport openpyxlimport numpy as npimport timeimport xlrddata &#x3D; pd.read_csv(&#39;myfile.csv&#39;, header&#x3D;0, sep&#x3D;&#39;,&#39;, encoding&#x3D;&#39;gbk&#39;)pd.set_option(&#39;display.max_columns&#39;, None)print(data)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/2022/04/30/python-pandas-note/image-20220501100819754.png" alt="全部数据"></p><h4 id="空值处理"><a href="#空值处理" class="headerlink" title="空值处理"></a>空值处理</h4><p>在查看所有的数据以后，我们发现原始的数据的第二列（在<code>Dataframe</code>中是索引<code>loc[0]</code>），这时候我们对数据行进行一些处理，把<code>NaN</code>行先去掉，就可以在读取的时候直接跳过这行，<code>Drawing No</code>也是一个空数据，在后续的处理中去掉。两种种方法去处理NaN值：</p><p><em><strong>读取的时候直接跳过</strong></em></p><pre class="line-numbers language-none"><code class="language-none">import pandas as pddata &#x3D; pd.read_csv(&#39;myfile.csv&#39;, header&#x3D;0, sep&#x3D;&#39;,&#39;, skiprows&#x3D;[1], usecols&#x3D;[0, 1, 2, 3, 5, 6, 7, 8, 9, 10, 11],                   encoding&#x3D;&#39;gbk&#39;)pd.set_option(&#39;display.max_columns&#39;, None)  # 显示全部列pd.set_option(&#39;display.unicode.ambiguous_as_wide&#39;, True)  # 列名称数据对齐pd.set_option(&#39;display.unicode.east_asian_width&#39;, True)  # 列名称数据对齐print(data.head())  # 打印前5行<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/2022/04/30/python-pandas-note/image-20220501111255451.png" alt="直接在读取的时候去掉空值"></p><p><em><strong>读取完毕再处理</strong></em></p><p>我们很多时候数据缺失并不是整行或者整列的，我们读取之后再来处理</p><pre class="line-numbers language-none"><code class="language-none">import pandas as pdimport openpyxlimport numpy as npimport timeimport xlrddata &#x3D; pd.read_csv(&#39;myfile.csv&#39;, header&#x3D;0, sep&#x3D;&#39;,&#39;,                   encoding&#x3D;&#39;gbk&#39;)pd.set_option(&#39;display.max_columns&#39;, None)  # 显示全部列pd.set_option(&#39;display.unicode.ambiguous_as_wide&#39;, True)  # 列名称数据对齐pd.set_option(&#39;display.unicode.east_asian_width&#39;, True)  # 列名称数据对齐# print(data.head())  # 打印前5行print(data.columns)  # 查看列名columns &#x3D; data.columns  # 赋值给columnsprint(type(columns))  # 查看类型&lt;class &#39;pandas.core.indexes.base.Index&#39;&gt;data.replace(&#39;$NULL$&#39;, np.nan, inplace&#x3D;True)  # 替换字符串为nan<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none"># 对于列的缺失，我们提供两个思路处理# for col in columns:#     # print(data[col].count())#     if data[col].count() &#x3D;&#x3D; 0:  # 判断是否全空#         data.drop(labels&#x3D;col, axis&#x3D;1, inplace&#x3D;True)-----------------------------第二种col &#x3D; data.count() &#x3D;&#x3D; 0print(col) #返回的是每列的布尔值len &#x3D; len(col)print(len)for i in range(len):    if col[i]:        data.drop(labels&#x3D;col.index[i],axis&#x3D;1,inplace&#x3D;True)print(data)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/2022/04/30/python-pandas-note/image-20220501121112252.png" alt="将Drawing No这个无效列去除"></p><p>我们再用<code>data.isnull().sum()</code>去对数据表空值进行统计，方便后续处理</p><p><img src="/2022/04/30/python-pandas-note/image-20220501121328869.png" alt="统计空值"></p><p>用<code>dropna</code>方法去除空行，指定 <code>how=&#39;all&#39;</code></p><pre class="line-numbers language-none"><code class="language-none">data1 &#x3D; data.dropna(axis&#x3D;0, how&#x3D;&#39;all&#39;, thresh&#x3D;None, subset&#x3D;None, inplace&#x3D;False)#只有全部为空才回被删除print(data1)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>参数说明：</strong></p><ul><li>axis：默认为 0，表示逢空值剔除整行，如果设置参数 axis＝1 表示逢空值去掉整列。</li><li>how：默认为 ‘any’ 如果一行（或一列）里任何一个数据有出现 NA 就去掉整行，如果设置 how&#x3D;’all’ 一行（或列）都是 NA 才去掉这整行。</li><li>thresh：设置需要多少非空值的数据才可以保留下来的。</li><li>subset：设置想要检查的列。如果是多个列，可以使用列名的 list 作为参数。</li><li>inplace：如果设置 True，将计算得到的值直接覆盖之前的值并返回 None，修改的是源数据。</li></ul><p><img src="/2022/04/30/python-pandas-note/image-20220501122356900.png" alt="去除全部是空的行"></p><p>假如这样行列处理完毕以后，我们数据还是有某些个值缺失，数据量大的时候可以这么做</p><pre class="line-numbers language-none"><code class="language-none">data_isnull &#x3D; data[data.isnull().values &#x3D;&#x3D; True] #查找所有空值<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/2022/04/30/python-pandas-note/image-20220502084330664.png" alt="缺失数据"></p><p>很轻松就找到了整个表有缺失的值</p><p>另外补充查看各个列缺失情况的方法如下</p><pre class="line-numbers language-none"><code class="language-none">data.isnull().sum() #8、对缺失值进行统计，统计出每一个字段有多少缺失值。# 光看缺失值数量 却不对比总样本数是不对的。data.isnull().mean() # 可以查看各列缺失值的比例data.drop(columns&#x3D;&#39;xx&#39;,inplace&#x3D;True) #删除缺失值大于某个比例的列data&#x3D;data.loc[:,df.isnull().mean()&lt;0.5] #剔除缺失值比例大于50%的列data.dropna() #删除所有缺失值所在的行和列，像炸弹一样横纵两列都消失其他的:data.fillna() # 填充缺失值。data[&#39;age&#39;].fillna(data[&#39;age&#39;].mean())  # 用均值填充data[&#39;age&#39;].fillna(method&#x3D;&#39;bfill&#39;)  # 用此空后面的值填充data[&#39;age&#39;].fillna(method&#x3D;&#39;ffill&#39;)  # 用此空前面的值填充，有顺序的序列可以此二法填充<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>查找na所在的行和列</p><pre class="line-numbers language-none"><code class="language-none">position &#x3D; data.isnull().stack()[lambda x:x].index.tolist()print(position) #[(5, &#39;Part Name&#39;)]-----------小例子-----------#!&#x2F;usr&#x2F;bin&#x2F;evn python# -*-coding:utf8 -*-import pandas as pddata &#x3D; [[None, None, 90, 80],[57, 43, 89, 65],[78, 50, 67, 78],[None, 78, 90, 73],[67, 45, 78, 76],[77, 88, None, 45],[52, 110, 120, 99],[131, 13, 32, 12]]index &#x3D; [&#39;语文&#39;, &#39;英语&#39;, &#39;数学&#39;, &#39;政治&#39;, &#39;物理&#39;, &#39;化学&#39;, &#39;生物&#39;, &#39;地理&#39;]column &#x3D; [&#39;张三&#39;, &#39;李四&#39;, &#39;王五&#39;, &#39;周六&#39;]data &#x3D; pd.DataFrame(data,index&#x3D;index,columns&#x3D;column)print(data)print(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&quot;)for columname in data.columns:    if data[columname].count() !&#x3D; len(data):         loc &#x3D; data[columname][data[columname].isnull().values&#x3D;&#x3D;True].index.tolist()         print(&#39;列名：&quot;&#123;&#125;&quot;, 第&#123;&#125;行位置有缺失值&#39;.format(columname,loc))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h4><pre class="line-numbers language-none"><code class="language-none"># 索引# 直接使用索引行列print(data[&#39;Part Name&#39;][5])# 使用locprint(data.loc[5,&#39;Part Name&#39;])print(data.loc[data[&#39;Part Name&#39;].isnull()])   #等价于print(data[data[&#39;Part Name&#39;].isnull()])print(&#39;-&#39; * 20)print(data[data[&#39;Part Name&#39;].isnull()])# 使用iloc,返回的是个dataframeprint(data.iloc[4:5,1:2])*****************nannan   S&#x2F;N Part Name Material Grade  Thickness    Mark No  Weight  Surface Area  \5  5.0       NaN          Q355B       18.0  a-2P-1239   141.3         2.185                      Ref. No  Qty Nesting Task  Nested Qty  5  （B105-0042）施工总承包  2.0     myfile02         0.0  --------------------   S&#x2F;N Part Name Material Grade  Thickness    Mark No  Weight  Surface Area  \5  5.0       NaN          Q355B       18.0  a-2P-1239   141.3         2.185                      Ref. No  Qty Nesting Task  Nested Qty  5  （B105-0042）施工总承包  2.0     myfile02         0.0    Part Name5       NaN<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="修改单元格的值"><a href="#修改单元格的值" class="headerlink" title="修改单元格的值"></a>修改单元格的值</h4><pre class="line-numbers language-none"><code class="language-none">data.loc[5,&#39;Part Name&#39;] &#x3D; data.loc[5,&#39;Mark No&#39;]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/2022/04/30/python-pandas-note/image-20220502112841786.png" alt="修改单元格的值"></p><h5 id="基本运算"><a href="#基本运算" class="headerlink" title="基本运算"></a>基本运算</h5><h6 id="行间运算"><a href="#行间运算" class="headerlink" title="行间运算"></a>行间运算</h6><p>在实例表中行间加法无意义，简单示例</p><p>加法</p><p><code>data[columns1]+ data[columns2]</code>列之间相加<strong>columns</strong>是索引</p><p>对于行间所有数据求和，除了上述方法一个一个加外还可以</p><p><code>data.eval(&#39;合计=columns1+columns2+columns3&#39;)</code></p><p>或者</p><p><code>data.sum(axis=1)</code>指定轴是列</p><p>将求和数据储存到<code>dataframe</code>中</p><p><code>data[合计] = data.sum(axis=1)</code></p><p>四则运算同理，减法，乘法，除法不再一一列出。</p><h6 id="比较运算"><a href="#比较运算" class="headerlink" title="比较运算"></a>比较运算</h6><p><code>data[columns1]&gt;&lt;data[columns2]</code>返回的是一组布尔值</p><p>也可以通过<code>query()</code>函数查看结果</p><p><code>data.query([columns1&gt;[columns2])</code></p><p>同等于<code>data[data[columns1]&gt;&lt;data[columns2]]</code></p><p><code>data.query([columns1==&#39;A&#39;)</code></p><p>同等于<code>data[data[columns1]==[A]]</code></p><p><strong>这两个方法都可以查看到比较运算的表结果</strong></p><h6 id="汇总运算"><a href="#汇总运算" class="headerlink" title="汇总运算"></a>汇总运算</h6><p>即对行之间的运算函数</p><p>count() 计数函数，会统计数据中非空个数</p><p><code>data.count()</code></p><p>类似len()和shape但是更加详细</p><p>省缺参数默认纵向统计，指定<code>data.count(axis=1)</code>可以横向统计列之间的空值</p><p>sum()</p><p>前面也展示了sum()的用法</p><p>默认省缺参数是对纵向求和，data.sum(axis&#x3D;1)是对横向求和</p><p>mean()</p><p>平均数函数，类似sum()</p><p>可以指定内部参与运算的列和行，例如</p><p><code>data.mean(columns1，columns1)</code></p><p>除以上计算外，Pandas还支持最大值max()，最小值min()，另外进阶函数有：中位数函数median()、求众数函数mode()、方差函数var()、标准差函数std()、分位数函数quantile()和相关性函数corr()。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>花了三天时间把之前的笔记整理出来，很多有意思的东西也重新复习了一下，类似高阶数组的广播，高阶数组的轴向表示方法都重新复习了一遍。</p><p>接下来就是将PIL和matplotlib整理出来，先贴上一代码防止找不到</p><pre class="line-numbers language-none"><code class="language-none">#图像手绘模拟from PIL import Imageimport numpy as npa &#x3D; np.array(Image.open(r&quot;C:\Users\LENOVO\Desktop\21c55b005c746518e5e9f3522d9416b5.jpg&quot;).convert(&#39;L&#39;)).astype(&#39;float&#39;)depth &#x3D; 10grad &#x3D; np.gradient(a)   #获取图像灰度梯度grad_x,grad_y &#x3D; grad    #获取横纵梯度值grad_x&#x3D;grad_x*depth&#x2F;100.    #横向归一整理grad_y&#x3D;grad_y*depth&#x2F;100.    #纵向归一整理A &#x3D; np.sqrt(grad_x**2+grad_y**2+1.)uni_x &#x3D; grad_x&#x2F;Auni_y &#x3D; grad_y&#x2F;Auni_z &#x3D; 1.&#x2F;A    #得到归一单位法向量值vec_el &#x3D; np.pi&#x2F;2.2  #建立光源三维坐标体系，对应横纵弧长vec_az &#x3D; np.pi&#x2F;4.dx &#x3D; np.cos(vec_el)*np.cos(vec_az)  #获取光源具体位置，计算影响因子dy &#x3D; np.cos(vec_el)*np.sin(vec_az)dz &#x3D; np.sin(vec_el)b &#x3D; 225*(dx*uni_x+dy*uni_y+dz*uni_z)    #归一求出具体的光源影响量b&#x3D;b.clip(0,225)     #避免数据溢出im &#x3D; Image.fromarray(b.astype(&#39;uint8&#39;))     #用framarry将得到的灰度转换为对应数组im.save(r&quot;C:\Users\LENOVO\Desktop\手绘.jpg&quot;)      #保存图形<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">#import  matplotlib.pyplot as plt    #重新定义matplotlib的函数为pltimport numpy as np&quot;&quot;&quot;plt.subplot2grid((3,3),(0,0),colspan&#x3D;3)plt.plot([0,2,4,6,8],[3,1,4,5,2])   #建立一个x坐标是02468Y，y坐标是31452的元素 绘制折线图plt.ylabel(&#39;纵坐标&#39;,fontproperties&#x3D;&#39;SimHei&#39;,fontsize&#x3D;25,color&#x3D;&#39;green&#39;)     #y轴标签为Gradeplt.xlabel(&#39;横坐标&#39;,fontproperties&#x3D;&#39;SimHei&#39;,fontsize&#x3D;25,color&#x3D;&#39;green&#39;)plt.title(&#39;示例&#39;,fontproperties&#x3D;&#39;SimHei&#39;,fontsize&#x3D;25)plt.annotate(&#39;this is anne&#39;,xy&#x3D;(6,4.5),xytext&#x3D;(4,2),arrowprops&#x3D;dict(facecolor&#x3D;&#39;black&#39;,shrink&#x3D;0.1,width&#x3D;1)) plt.axis([-1,10,0,6])   #x轴从-1到10，Y轴从0到6，另外subplot可以分割绘图区域plt.subplot2grid((3,3),(1,0),colspan&#x3D;2) #分割绘图区域labels &#x3D; &#39;Frogs&#39;,&#39;Hogs&#39;,&#39;Dogs&#39;,&#39;Logs&#39;   #柱状图sizes &#x3D; [15,30,45,10]explode &#x3D; (0,0.1,0,0)plt.pie(sizes,explode&#x3D;explode,labels&#x3D;labels,autopct&#x3D;&#39;%1.1f%%&#39;,shadow&#x3D;False,startangle&#x3D;90)plt.axis(&#39;equal&#39;)plt.subplot2grid((3,3),(1,2),rowspan&#x3D;2)np.random.seed(0)mu,sigma &#x3D; 100,20   #均值和标准差a &#x3D; np.random.normal(mu,sigma,size&#x3D;100)plt.hist(a,40,density&#x3D;1,histtype&#x3D;&#39;stepfilled&#39;,facecolor&#x3D;&#39;blue&#39;,alpha&#x3D;0.75)plt.title(&#39;Histogram&#39;)plt.subplot2grid((3,3),(2,0))&quot;&quot;&quot;N&#x3D;20    #饼图theta&#x3D;np.linspace(0.0,2*np.pi,N,endpoint&#x3D;False)radii &#x3D; 10*np.random.rand(N)width&#x3D;np.pi&#x2F;4*np.random.rand(N)ax &#x3D; plt.subplot(111,projection&#x3D;&#39;polar&#39;)bars &#x3D; ax.bar(theta,radii,width&#x3D;width,bottom&#x3D;0.0)for r,bar in zip(radii,bars):    bar.set_facecolor(plt.cm.viridis(r&#x2F;10.))    bar.set_alpha(0.5)#plt.subplot2grid((3,3),(2,1))plt.grid(True)plt.show()  #输出图形<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;pandas基本功能&quot;&gt;&lt;a href=&quot;#pandas基本功能&quot; class=&quot;headerlink&quot; title=&quot;pandas基本功能&quot;&gt;&lt;/a&gt;pandas基本功能&lt;/h3&gt;&lt;p&gt;使用的是tekla13.0版本套料工具生成工程时，形成的&lt;code&gt;repo</summary>
      
    
    
    
    <category term="Python" scheme="http://huangxiaoruipo.github.io/categories/Python/"/>
    
    
    <category term="Python" scheme="http://huangxiaoruipo.github.io/tags/Python/"/>
    
    <category term="pandas" scheme="http://huangxiaoruipo.github.io/tags/pandas/"/>
    
  </entry>
  
  <entry>
    <title>accordion特效</title>
    <link href="http://huangxiaoruipo.github.io/2022/04/30/accordion-te-xiao/"/>
    <id>http://huangxiaoruipo.github.io/2022/04/30/accordion-te-xiao/</id>
    <published>2022-04-30T03:55:30.000Z</published>
    <updated>2022-04-30T04:10:38.805Z</updated>
    
    <content type="html"><![CDATA[<h3 id="收集到了一个很好看的手风琴特效"><a href="#收集到了一个很好看的手风琴特效" class="headerlink" title="收集到了一个很好看的手风琴特效"></a>收集到了一个很好看的手风琴特效</h3><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="800" height="360" src="/myapp/accordion/"></iframe><h3 id="CSS源码"><a href="#CSS源码" class="headerlink" title="CSS源码"></a>CSS源码</h3><pre class="line-numbers language-none"><code class="language-none">&lt;style&gt;    *&#123;        margin: 0;        padding: 0;        box-sizing: border-box;    &#125;    body&#123;        height: 100vh;        display: flex;        justify-content: center;        align-items: center;        background-color: #eef1f5;    &#125;    .loading&#123;        display: flex;        flex-direction: row;    &#125;    .loading div&#123;        position: relative;        width: 40px;        height: 200px;        background: linear-gradient(to bottom,rbga(0,0,0,0.05));        margin: 20px;        border-radius: 20px;        border: 2px solid #eef1f5;        box-shadow: 15px 15px 20px rgba(0, 0, 0, 0.1),        -15px -15px 20px #fff,        inset -5px -5px 5px rgba(255, 255, 255, 0.5),        inset 5px 5px 5px rgba(0, 0, 0, 0.5);        overflow: hidden;    &#125;    .loading div::before&#123;        content: &quot;&quot;;        position: absolute;        top: 0;        left: 0;        width: 36px;        height: 36px;        border-radius: 50%;        box-shadow: inset -5px -5px 5px rgba(0, 0, 0,0.1),        0 420px 0 400px lightblue;        animation: animate 2s ease-in-out infinite;        animation-delay: calc(var(--x)*0.3s);        transform: translateY(160px);    &#125;    @keyframes animate &#123;                0%&#123;            transform: translateY(160px);            filter: hue-rotate(0deg);                    &#125;        50%&#123;            transform: translateY(0px);            filter: hue-rotate(180deg);        &#125;        100%&#123;            transform: translateY(160px);            filter: hue-rotate(360deg);        &#125;    &#125;&lt;&#x2F;style&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h3><pre class="line-numbers language-none"><code class="language-none">&lt;body&gt;    &lt;div class&#x3D;&quot;loading&quot;&gt;        &lt;div style&#x3D;&quot;--x:0&quot;&gt;&lt;&#x2F;div&gt;        &lt;div style&#x3D;&quot;--x:1&quot;&gt;&lt;&#x2F;div&gt;        &lt;div style&#x3D;&quot;--x:2&quot;&gt;&lt;&#x2F;div&gt;        &lt;div style&#x3D;&quot;--x:3&quot;&gt;&lt;&#x2F;div&gt;        &lt;div style&#x3D;&quot;--x:4&quot;&gt;&lt;&#x2F;div&gt;        &lt;div style&#x3D;&quot;--x:5&quot;&gt;&lt;&#x2F;div&gt;      &lt;&#x2F;div&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;收集到了一个很好看的手风琴特效&quot;&gt;&lt;a href=&quot;#收集到了一个很好看的手风琴特效&quot; class=&quot;headerlink&quot; title=&quot;收集到了一个很好看的手风琴特效&quot;&gt;&lt;/a&gt;收集到了一个很好看的手风琴特效&lt;/h3&gt;&lt;iframe frameborder=&quot;</summary>
      
    
    
    
    <category term="CSS" scheme="http://huangxiaoruipo.github.io/categories/CSS/"/>
    
    
    <category term="HTML" scheme="http://huangxiaoruipo.github.io/tags/HTML/"/>
    
    <category term="CSS" scheme="http://huangxiaoruipo.github.io/tags/CSS/"/>
    
    <category term="CSS3" scheme="http://huangxiaoruipo.github.io/tags/CSS3/"/>
    
  </entry>
  
  <entry>
    <title>Python numpy基础（一）</title>
    <link href="http://huangxiaoruipo.github.io/2022/04/28/python-numpy-ji-chu-yi/"/>
    <id>http://huangxiaoruipo.github.io/2022/04/28/python-numpy-ji-chu-yi/</id>
    <published>2022-04-28T10:01:43.000Z</published>
    <updated>2022-04-28T13:56:20.266Z</updated>
    
    <content type="html"><![CDATA[<h3 id="NumPy是什么"><a href="#NumPy是什么" class="headerlink" title="NumPy是什么"></a>NumPy是什么</h3><p>NumPy（numerical python）是python数据计算最重要的基础包。</p><p>可以说多数的科学计算、数据分析的模块都是用NumPy的数组最为基础构建的。</p><h3 id="为什么选择NumPy"><a href="#为什么选择NumPy" class="headerlink" title="为什么选择NumPy"></a>为什么选择NumPy</h3><ul><li>使用连续内存块储存数据，独立其他的Python内置对象。基于C语言编写的算法库可以直接操作内存，不必进行类型检查或者其他的前期工作。（抄来的，理解不了）</li><li>NumPy数组使用的内存更少，直接对数组进行复杂的计算，不需要使用for循环。</li></ul><pre class="line-numbers language-none"><code class="language-none">list1 &#x3D; [1,2,5,8]list2 &#x3D; [1,1,5,1000]print(list1 &gt; list2) &#x2F;&#x2F;Trueprint(list2 &gt; list1) &#x2F;&#x2F;False# 挨个比较元素，如果首次比较到的元素大&#x2F;小，则按照顺序输出True&#x2F;False<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="NumPy的强大"><a href="#NumPy的强大" class="headerlink" title="NumPy的强大"></a>NumPy的强大</h3><p>NumPy可以使用for循环或者其他循环体去直接对数组进行加减乘除的运算和比较，减少代码的使用量和节省内存、运行时间等。</p><h3 id="NumPy的使用方法"><a href="#NumPy的使用方法" class="headerlink" title="NumPy的使用方法"></a>NumPy的使用方法</h3><h4 id="直接创建array列表"><a href="#直接创建array列表" class="headerlink" title="直接创建array列表"></a>直接创建array列表</h4><pre class="line-numbers language-none"><code class="language-none">import numpy as nplist1 &#x3D; [1, 4, 5, 7, 9, 20]arr1 &#x3D; np.array(list1)list2 &#x3D; list(&#39;abcde&#39;)  # [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;]arr2 &#x3D; np.array(list2)print(arr1)  # [ 1  4  5  7  9 20]print(arr2)  # [&#39;a&#39; &#39;b&#39; &#39;c&#39; &#39;d&#39; &#39;e&#39;]# 计算arr1arr3 &#x3D; (arr1 + 1) ** 2print(arr3)  # [  4  25  36  64 100 441]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以发现numpy使用array()可以很简单就将List类型转化为numpy数组，进而可以很快的对每个元素进行运算，不需要再去<code>for i in list：</code>去遍历数组，计算每个数据的平方和<code>（i = i**2）</code>,再去<code>res = append[i]</code>，这样写简直不要太麻烦！！！</p><h4 id="用np-arange-beg-end-step-创建数组"><a href="#用np-arange-beg-end-step-创建数组" class="headerlink" title="用np.arange(beg,end,step)创建数组"></a>用np.arange(beg,end,step)创建数组</h4><pre class="line-numbers language-none"><code class="language-none">import numpy as np# 创建0-4的一个数组arr4 &#x3D; np.arange(5)print(arr4)  # [0 1 2 3 4]# 创建一个10-14的数组arr5 &#x3D; np.arange(10, 15)print(arr5)  # [10 11 12 13 14]# 创建一个10-20，步长为2的等差数列数组arr6 &#x3D; np.arange(10, 20, 2)print(arr6)  # [10 12 14 16 18]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此外我们可以使用shape元素去查看数组的形状，reshape修改数组的形状。</p><pre class="line-numbers language-none"><code class="language-none">import numpy as nplist1 &#x3D; np.arange(12).reshape(3, 4)  # 创建一个0-11,且为3行4列的数组list2 &#x3D; np.arange(10, 22).reshape(3, 4)  # 创建一个10-21，且为4行4列的数组list3 &#x3D; list2 - list1print(list1)# [[ 0  1  2  3]#  [ 4  5  6  7]#  [ 8  9 10 11]]print(list2)# [[10 11 12 13]#  [14 15 16 17]#  [18 19 20 21]]print(list3)# [[10 10 10 10]#  [10 10 10 10]#  [10 10 10 10]]print(list1.shape)  # (3, 4)print(np.arange(10, 20).shape)  # (10,)arr1 &#x3D; np.arange(24).reshape(3,2,4) # 这是一个三维数组，# numpy对数组的约定是这样的，第一个维度指的是数组有几层（3层）# 第二个维度指的是数组每层有多数行（2行）# 第三个维度指的是每行有多少个元素（4个）# 简记为3层，后面2个表示2行4列的线性数列print(arr1)# [[[ 0  1  2  3]#   [ 4  5  6  7]]##  [[ 8  9 10 11]#   [12 13 14 15]]##  [[16 17 18 19]#   [20 21 22 23]]]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果shape返回的是(10,)则说明它是一个一维数组，(3, 4)二维数组，更多的(3,2,4)</p><h4 id="zeros，zeros-like-ones，ones-like-empyty，empyty-like"><a href="#zeros，zeros-like-ones，ones-like-empyty，empyty-like" class="headerlink" title="zeros，zeros_like,ones，ones_like,empyty，empyty_like"></a>zeros，zeros_like,ones，ones_like,empyty，empyty_like</h4><p>见名知意，zero指的是创建值全是0的数组</p><p>zeros_like创建一个和指定数组形状一样的，值是0的数组</p><p>同理是ones，ones_like,empyty，empyty_like</p><p>ones元素全部为1，empyty全部变为空值，占位符是1.</p><pre class="line-numbers language-none"><code class="language-none">import numpy as nparr1 &#x3D; np.arange(12)arr2 &#x3D; arr1.reshape(3,4)arr3 &#x3D; np.ones(12)arr4 &#x3D; np.ones((3,3))arr5 &#x3D; np.ones_like(arr2)print(arr1)print(arr2)print(arr3)print(arr4)print(arr5)arr1# [ 0  1  2  3  4  5  6  7  8  9 10 11]arr2# [[ 0  1  2  3]#  [ 4  5  6  7]#  [ 8  9 10 11]]arr3# [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]arr4# [[1. 1. 1.]#  [1. 1. 1.]#  [1. 1. 1.]]arr5# [[1 1 1 1]#  [1 1 1 1]#  [1 1 1 1]]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="eye创建对角矩阵数组"><a href="#eye创建对角矩阵数组" class="headerlink" title="eye创建对角矩阵数组"></a>eye创建对角矩阵数组</h4><pre class="line-numbers language-none"><code class="language-none">import numpy as nparr1 &#x3D; np.eye(5)print(arr1)# [[1. 0. 0. 0. 0.]#  [0. 1. 0. 0. 0.]#  [0. 0. 1. 0. 0.]#  [0. 0. 0. 1. 0.]#  [0. 0. 0. 0. 1.]]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="full创建满数组"><a href="#full创建满数组" class="headerlink" title="full创建满数组"></a>full创建满数组</h4><pre class="line-numbers language-none"><code class="language-none">import numpy as nparr2 &#x3D; np.full((3,4),123)print(arr2# [[123 123 123 123]#  [123 123 123 123]#  [123 123 123 123]]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="numpy数组的数据类型"><a href="#numpy数组的数据类型" class="headerlink" title="numpy数组的数据类型"></a>numpy数组的数据类型</h3><p>python的list列表，其中可以储存所有的数据类型，但是并不是所有的类型都是储存在list中，耳数把对象的索引储存在list，当垃圾回收机制检测的时候，需要一个个区域遍历，占用资源大，numpy开辟了一整块内存，相当于只有一个对象来粗存这值，所以只需要把索引打包成一个对象，这个对象里面只能去储存一种数据类型。</p><p><img src="/2022/04/28/python-numpy-ji-chu-yi/image-20220428205422893.png" alt="dttype的类型"></p><pre class="line-numbers language-none"><code class="language-none">import numpy as nplist1 &#x3D; [0,1.1,2.2,3.3,4.4,5.5,6.6]# 创建数组的时候选择一个数据类型arr1 &#x3D; np.array(list1,dtype&#x3D;np.int16)print(arr1)print(arr1.dtype)arr2 &#x3D; arr1.astype(np.float32)print(arr2)print(arr2.dtype)# [0 1 2 3 4 5 6]# int16# [0. 1. 2. 3. 4. 5. 6.]# float32<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 可以发现，我们能将numpy数组的dtype类型在创建的时候定义，也可以在我们创建好后重新转换我们的数据类型。</p><p><strong>注意</strong></p><ol><li><em>当float转换为int的时候，会自动删除小数点之后的数据，只保留整数位</em></li><li><em>数字转换成字符串也是可以的</em></li></ol><h3 id="numpy数组的索引类型"><a href="#numpy数组的索引类型" class="headerlink" title="numpy数组的索引类型"></a>numpy数组的索引类型</h3><h4 id="普通索引和数据切片"><a href="#普通索引和数据切片" class="headerlink" title="普通索引和数据切片"></a>普通索引和数据切片</h4><pre class="line-numbers language-none"><code class="language-none">import numpy as nplist1 &#x3D; np.arange(12).reshape(3,4)print(list1)print(list1[1,1])print(list1[1:,1:])  # 输出第二行之后，并且第二列之后# [[ 0  1  2  3]#  [ 4  5  6  7]#  [ 8  9 10 11]]# 5# [[ 5  6  7]#  [ 9 10 11]]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="花式索引"><a href="#花式索引" class="headerlink" title="花式索引"></a>花式索引</h4><pre class="line-numbers language-none"><code class="language-none">import numpy as nplist1 &#x3D; np.arange(24).reshape(6, 4)print(list1)print(&#39;-&#39; * 20)print(list1[[1, 4, 3]])# [[ 0  1  2  3]#  [ 4  5  6  7]#  [ 8  9 10 11]#  [12 13 14 15]#  [16 17 18 19]#  [20 21 22 23]]# --------------------# [[ 4  5  6  7]#  [16 17 18 19]#  [12 13 14 15]]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>若是需要确切值可以这么写</p><pre class="line-numbers language-none"><code class="language-none">import numpy as nplist1 &#x3D; np.arange(24).reshape(6, 4)print(list1)print(&#39;-&#39; * 20)print(list1[[1, 4, 3]])print(&#39;-&#39; * 20)print(list1[[1, 4, 3],[2,3,0]])# [[ 0  1  2  3]#  [ 4  5  6  7]#  [ 8  9 10 11]#  [12 13 14 15]#  [16 17 18 19]#  [20 21 22 23]]# --------------------# [[ 4  5  6  7]#  [16 17 18 19]#  [12 13 14 15]]# --------------------# [ 6 19 12]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="布尔索引"><a href="#布尔索引" class="headerlink" title="布尔索引"></a>布尔索引</h4><pre class="line-numbers language-none"><code class="language-none">import numpy as nplist1 &#x3D; np.arange(24).reshape(6, 4)index &#x3D; [True,False,True,False,True,False]print(list1)print(&#39;-&#39; * 20)print(list1[index])# [[ 0  1  2  3]#  [ 4  5  6  7]#  [ 8  9 10 11]#  [12 13 14 15]#  [16 17 18 19]#  [20 21 22 23]]# --------------------# [[ 0  1  2  3]#  [ 8  9 10 11]#  [16 17 18 19]]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="numpy自带的数组函数"><a href="#numpy自带的数组函数" class="headerlink" title="numpy自带的数组函数"></a>numpy自带的数组函数</h3><h4 id="通用函数：快速的元素级数组函数"><a href="#通用函数：快速的元素级数组函数" class="headerlink" title="通用函数：快速的元素级数组函数"></a>通用函数：快速的元素级数组函数</h4><p>常用一元ufunc：</p><p><img src="/2022/04/28/python-numpy-ji-chu-yi/image-20220428212328292.png" alt="常用一元ufunc"></p><p>常用二元ufunc：</p><p><img src="/2022/04/28/python-numpy-ji-chu-yi/image-20220428212503504.png" alt="常用一元ufunc："></p><p>补充一下</p><pre class="line-numbers language-none"><code class="language-none"># where(表达式，f1,f2),类似于三目运算符# 表达式为True返回f1，表达式为False返回f2# arr2: [[19  3 19 -1 -2]#  [ 8  5  3 19  5]#  [-8 16 -1  6  4]#  [ 0 17 -3 18  3]]arr2 &#x3D; np.where(arr2 &#x3D;&#x3D; 0,1,arr2) #  意思是arr2里面的元素是0时，返回该元素是1，不是0就返回该元素本身print(arr2)# 输出# [[19  3 19 -1 -2]#  [ 8  5  3 19  5]#  [-8 16 -1  6  4]#  [ 1 17 -3 18  3]]————————————————<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;NumPy是什么&quot;&gt;&lt;a href=&quot;#NumPy是什么&quot; class=&quot;headerlink&quot; title=&quot;NumPy是什么&quot;&gt;&lt;/a&gt;NumPy是什么&lt;/h3&gt;&lt;p&gt;NumPy（numerical python）是python数据计算最重要的基础包。&lt;/p&gt;</summary>
      
    
    
    
    <category term="Python" scheme="http://huangxiaoruipo.github.io/categories/Python/"/>
    
    
    <category term="Python" scheme="http://huangxiaoruipo.github.io/tags/Python/"/>
    
    <category term="NumPy" scheme="http://huangxiaoruipo.github.io/tags/NumPy/"/>
    
  </entry>
  
  <entry>
    <title>Excel数据表函数基本操作</title>
    <link href="http://huangxiaoruipo.github.io/2022/04/25/excel-shu-ju-biao-han-shu-ji-ben-cao-zuo/"/>
    <id>http://huangxiaoruipo.github.io/2022/04/25/excel-shu-ju-biao-han-shu-ji-ben-cao-zuo/</id>
    <published>2022-04-25T02:35:40.000Z</published>
    <updated>2022-04-25T09:43:37.559Z</updated>
    
    <content type="html"><![CDATA[<h3 id="VLOOKUP-函数"><a href="#VLOOKUP-函数" class="headerlink" title="VLOOKUP 函数"></a>VLOOKUP 函数</h3><h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><p><code>=VLOOKUP (要查找的项、要查找位置、区域中包含要返回的值的列号、返回近似匹配或精确匹配 - 指示为 1/TRUE 或 0/FALSE) 。</code></p><p><code>=VLOOKUP (lookup_value, table_array, col_index_num, [range_lookup]) </code></p><h4 id="VLOOKUP-引用Excel官方的例子"><a href="#VLOOKUP-引用Excel官方的例子" class="headerlink" title="VLOOKUP 引用Excel官方的例子"></a>VLOOKUP 引用Excel官方的例子</h4><p><img src="/2022/04/25/excel-shu-ju-biao-han-shu-ji-ben-cao-zuo/image-20220425105128317.png" alt="图例"></p><p>我们可以使用VLOOKUP函数<code>=VLOOKUP（105,A2:E7,5,FALSE）</code>表示去查找ID是105，在表内A2:E7的RANGE，返回的值是第5列的单元格内容，然后用一个YEARFRAC(开始时间，结束时间,时间格式)去返回一个时间间距<code>=YEARFRAC(DATE(2014,6,30),DATE(55,3,4),1)</code>，结果是59.3，用INT转为整数结果是图示的59。</p><h3 id="XLOOKUP-函数"><a href="#XLOOKUP-函数" class="headerlink" title="XLOOKUP 函数"></a>XLOOKUP 函数</h3><p>关于<code>VLOOKUP</code> ，在2021新版本以后官方支持了一个新的函数<code>XLOOKUP</code>，使用 <code>XLOOKUP</code> 函数按行查找表格或区域内容</p><h4 id="基本用法-1"><a href="#基本用法-1" class="headerlink" title="基本用法"></a>基本用法</h4><p><code>=XLOOKUP(lookup_value, lookup_array, return_array, [if_not_found], [match_mode], [search_mode])</code></p><table><thead><tr><th align="left">参数</th><th>说明</th></tr></thead><tbody><tr><td align="left"><strong>lookup_value</strong>             必需</td><td>要搜索的值   <em>如果省略，XLOOKUP 将返回它在 lookup_array*<em>中查找的空白lookup_array。</em></em></td></tr><tr><td align="left"><strong>lookup_array</strong>             必需</td><td>要搜索的数组或区域</td></tr><tr><td align="left"><strong>return_array</strong>              必需</td><td>要返回的数组或区域</td></tr><tr><td align="left"><strong>[if_not_found]</strong>             可选</td><td>如果找不到有效的匹配项，则返回你if_not_found [if_not_found] 文本。如果找不到有效的匹配项，并且缺少 [if_not_found]，<strong>则#N&#x2F;A。</strong></td></tr><tr><td align="left"><strong>[match_mode]</strong>             可选</td><td>指定匹配类型：0 - 完全匹配。 如果未找到，则返回 #N&#x2F;A。 这是默认选项。-1 - 完全匹配。 如果没有找到，则返回下一个较小的项。1 - 完全匹配。 如果没有找到，则返回下一个较大的项。2 - 通配符匹配，其中 *, ? 和 ~ 有<a href="https://support.office.com/zh-cn/f1/topic/%E5%9C%A8%E6%90%9C%E7%B4%A2%E4%B8%AD%E4%BD%BF%E7%94%A8%E9%80%9A%E9%85%8D%E7%AC%A6-ef94362e-9999-4350-ad74-4d2371110adb?NS=EXCEL&Version=19">特殊含义</a>。</td></tr><tr><td align="left"><strong>[search_mode]</strong>             可选</td><td>指定要使用的搜索模式：1 - 从第一项开始执行搜索。 这是默认选项。-1 - 从最后一项开始执行反向搜索。2 - 执行依赖于 lookup_array 按<em>升序</em>排序的二进制搜索。 如果未排序，将返回无效结果。2 - 执行依赖于 lookup_array 按<em>降序</em>排序的二进制搜索。 如果未排序，将返回无效结果。</td></tr></tbody></table><h4 id="非常好用"><a href="#非常好用" class="headerlink" title="非常好用"></a>非常好用</h4><h5 id="单条件查询，类似VLOOKUP"><a href="#单条件查询，类似VLOOKUP" class="headerlink" title="单条件查询，类似VLOOKUP"></a>单条件查询，类似VLOOKUP</h5><p><code>=XLOOKUP($A$16:$A$19,$A$2:$A$10,D2:D10,&quot;无&quot;)</code>这个查询方式针对单个数据对应，它可以使用数组，查找到对应数据，且默认使用精确匹配。</p><p><img src="/2022/04/25/excel-shu-ju-biao-han-shu-ji-ben-cao-zuo/image-20220425144918552.png" alt="单条件查询"></p><h5 id="模糊查询，指定通配符模式"><a href="#模糊查询，指定通配符模式" class="headerlink" title="模糊查询，指定通配符模式"></a>模糊查询，指定通配符模式</h5><p><code>=XLOOKUP(&quot;*&quot;&amp;D16&amp;&quot;*&quot;,$A$2:$A$10,$B$2:$B$10,&quot;没找到&quot;,2)</code> <code>XLOOKUP</code>默认不支持通配符匹配，只有将第五个参数选项设置为通配符模式<strong>2</strong></p><p>才支持通配符。</p><p><img src="/2022/04/25/excel-shu-ju-biao-han-shu-ji-ben-cao-zuo/image-20220425145930885.png" alt="通配符匹配模式"></p><p><img src="/2022/04/25/excel-shu-ju-biao-han-shu-ji-ben-cao-zuo/image-20220425150015610.png"></p><h5 id="区间查询，比LOOKUP好用多了"><a href="#区间查询，比LOOKUP好用多了" class="headerlink" title="区间查询，比LOOKUP好用多了"></a>区间查询，比LOOKUP好用多了</h5><p>原来的LOOKUP函数还要我们对表格进行有序排序，那可真的不方便，一旦打乱顺序，查找的数据不对了，用上XLOOKIP以后再也不用担心这个问题。</p><p><code>=XLOOKUP(E2,$F$15:$F$19,$G$15:$G$19,&quot;&quot;,1)</code>，第五个参数+1表示匹配最大值，-1表示匹配最小值。</p><p><img src="/2022/04/25/excel-shu-ju-biao-han-shu-ji-ben-cao-zuo/image-20220425150940139.png" alt="区间匹配"></p><h5 id="查询最后一条结果"><a href="#查询最后一条结果" class="headerlink" title="查询最后一条结果"></a>查询最后一条结果</h5><p>李四和王五两位同志在在最后几日发奋图强，提高了自己的评分，我们查询数据的时候按日期升序排列，</p><p><img src="/2022/04/25/excel-shu-ju-biao-han-shu-ji-ben-cao-zuo/image-20220425151855778.png" alt="查询最后数据条目"></p><h5 id="横向查询"><a href="#横向查询" class="headerlink" title="横向查询"></a>横向查询</h5><p>对于横向查询，直接单列使用的话可以类似纵向查询，直接输入查找值，匹配值和返回值就行了。但是对于多列，顺序要是打乱或者稍微格式不一致，就会出现查找错误的情况，这时候我们可以使用两个XLOOKUP来套嵌使用。</p><p><code>=XLOOKUP($A17,$A$2:$A$12,XLOOKUP(B$16,$A$1:$H$1,$A$2:$H$12))</code>内嵌的XLOOKUP函数负责返回一个正确单列，外侧的XLOOKUP函数负责去查询匹配需要的目标数据。</p><p><img src="/2022/04/25/excel-shu-ju-biao-han-shu-ji-ben-cao-zuo/image-20220425154458130.png" alt="横向交叉查询"></p><h5 id="多条件查询"><a href="#多条件查询" class="headerlink" title="多条件查询"></a>多条件查询</h5><p>XLOOKUP直接支持数组，不用像VLOOKUP函数一样需要使用数组公式转换</p><p><code>=XLOOKUP($A17&amp;$B17,XLOOKUP($A$16,$A$1:$H$1,$A$2:$H$12)&amp;XLOOKUP($B$16,$A$1:$H$1,$A$2:$H$12),XLOOKUP(C$16,$A$1:$H$1,$A$2:$H$12))</code></p><p>这次来点稍微复杂的，多条件+交叉表查询，用XLOOKUP去分别返：回查询数组（日期&amp;姓名），返回数组（销售额），通过限定行列的引用方式，就能直接粘贴到其他单元格使用。</p><p><img src="/2022/04/25/excel-shu-ju-biao-han-shu-ji-ben-cao-zuo/image-20220425160601879.png" alt="多条件查询套嵌"></p><p><img src="/2022/04/25/excel-shu-ju-biao-han-shu-ji-ben-cao-zuo/image-20220425160219114.png" alt="多条件查询"></p><h5 id="区域查询"><a href="#区域查询" class="headerlink" title="区域查询"></a>区域查询</h5><p><code>=SUM(XLOOKUP($B$17,$H$2:$H$12,G2:G12):XLOOKUP($B$18,H2:H12,G2:G12))</code>值得注意，这个返回的是有序的日期期间，其实就是返回了两个日期中间的数组，如果要求某个日期区间的单元格值，配合SUMIFS使用。</p><p><img src="/2022/04/25/excel-shu-ju-biao-han-shu-ji-ben-cao-zuo/image-20220425162253393.png" alt="区域查询求和"></p><h5 id="动态表查询"><a href="#动态表查询" class="headerlink" title="动态表查询"></a>动态表查询</h5><p>假设有结构一致的多张数据表，名称分别为2019 2020 2021 2022</p><p>2020（其余表不列出）</p><table><thead><tr><th>板块</th><th>销售额</th></tr></thead><tbody><tr><td>饮料</td><td>5000</td></tr><tr><td>食品</td><td>2200</td></tr><tr><td>日用</td><td>1000</td></tr></tbody></table><p>我们需要查询每年的不同板块的销售额可以通过INDIRECT引用单元格去构建<code>年</code>和<code>2020</code>的单元格分别是A1  ， B1</p><table><thead><tr><th>年</th><th>2020</th></tr></thead><tbody><tr><td>板块</td><td>销售额</td></tr><tr><td>饮料</td><td></td></tr><tr><td>食品</td><td></td></tr><tr><td>日用</td><td></td></tr><tr><td></td><td></td></tr></tbody></table><p>在单元格内输入<code>=XLOOKUP(A4,INDIRECT($B$1&quot;!A:A&quot;),INDIRECT($B$1&quot;!B:B&quot;))</code>可以查询到相关板块的数据，意思就是查询A4目标值，它的查询数组在表2020的A:A，返回值在2020的B:B。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>基本上这两个函数已经涵盖了我们所有需要用到的东西，XLOOKUP能代替INDEX+MATCH的工作内容，使用INDEX+MATCH套嵌的方法也能很好去制作出非常不错的动态查询效果。下面给出一个求满足某些条件求和的例子：</p><p><code>=SUMIFS(INDEX(数据查询表，0，MATCH(要查询的值标题,查询的表头源，查询方式))***``###上面这句就是通过查询标题所在的位置，通过INDEX去返回整个求和列，和XLOOKUP达到的效果是一样的###``***,INDEX(数据查询表,0,MATCH(要查询的值,表头源,查询方式))***``###上面这段的意思就是返回一个条件列###``***,查询条件)</code></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;VLOOKUP-函数&quot;&gt;&lt;a href=&quot;#VLOOKUP-函数&quot; class=&quot;headerlink&quot; title=&quot;VLOOKUP 函数&quot;&gt;&lt;/a&gt;VLOOKUP 函数&lt;/h3&gt;&lt;h4 id=&quot;基本用法&quot;&gt;&lt;a href=&quot;#基本用法&quot; class=&quot;head</summary>
      
    
    
    
    <category term="Excel" scheme="http://huangxiaoruipo.github.io/categories/Excel/"/>
    
    
    <category term="VLOOKUP" scheme="http://huangxiaoruipo.github.io/tags/VLOOKUP/"/>
    
    <category term="XLOOKUP" scheme="http://huangxiaoruipo.github.io/tags/XLOOKUP/"/>
    
    <category term="INDEX" scheme="http://huangxiaoruipo.github.io/tags/INDEX/"/>
    
    <category term="MATCH" scheme="http://huangxiaoruipo.github.io/tags/MATCH/"/>
    
    <category term="SUMIFS" scheme="http://huangxiaoruipo.github.io/tags/SUMIFS/"/>
    
  </entry>
  
  <entry>
    <title>Python快排实现原理及代码</title>
    <link href="http://huangxiaoruipo.github.io/2022/04/24/python-kuai-pai-shi-xian-yuan-li-ji-dai-ma/"/>
    <id>http://huangxiaoruipo.github.io/2022/04/24/python-kuai-pai-shi-xian-yuan-li-ji-dai-ma/</id>
    <published>2022-04-24T00:41:02.000Z</published>
    <updated>2022-04-24T01:50:09.399Z</updated>
    
    <content type="html"><![CDATA[<h3 id="快排原理"><a href="#快排原理" class="headerlink" title="快排原理"></a>快排原理</h3><p>在一串数组中选择任意一个数字为基准，将数组的数据和基准数据相比较，比基准大的数据在基准数字的右边，比基准小的数据在基准的左边，此时基准元素位于正确的位置，它无需参与排序，接着对拆分的数组进行递归，再次进行快速排序，直到序列中的所有记录均为有序序列。</p><p>快速排序用到了<strong>分而治之</strong>的思想，把大的拆成小的，小的拆成更小的。</p><h3 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h3><p>设定当前待排序序列为<code>alist[start:end]</code>，其中<code>start &lt;= end</code>，只有待排数据足够小的时候才会进行直接排序，否则按三步骤处理：</p><ol><li>分解<br>在<code>alist[start:end]</code>选定一个基准序列<code>mid = alist[start]</code>(注：这个基准可以是第一个元素、最后一个元素、中间元素等等，这里取第一个)。以此为标准，我们定义两个指针对<code>low = start</code> <code>high= end</code>,将待排序列遍历比较大小，划分为<code>alist[start]</code>– <code>mid</code>与<code>mid</code>–<code>alist[end]</code>序列，<code>mid</code>不参与排序，并使前者全部的元素值小于<code>mid</code>，后者的全部元素值大于等于<code>mid</code>。</li><li>递归<br>对于子序列，我们分别调用递归函数<code>quick_sort(alist, start, low - 1)</code>基准左边， <code>quick_sort(alist, low + 1, end)</code>基准右边，对其进行快速排序，退出条件自然是<code>start &gt;= end</code>，因为之前排序的时候，结束时<code>low</code>、<code>high</code>重合，我们可以将基准元素放到该位置，<code>alist[low] = mid</code>（<code>alist[high] = mid</code>也可以）。</li><li>合并<br>由于排序都是原地进行的，递归结束后，所有的元素都已经排序完毕。</li></ol><h3 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h3><pre class="line-numbers language-none"><code class="language-none">def quick_sort(alist, start, end):    &quot;&quot;&quot;快速排序&quot;&quot;&quot;    if start &gt;&#x3D; end:  # 递归的退出条件        return    mid &#x3D; alist[start]  # 设定起始的基准元素    low &#x3D; start  # low为序列左边在开始位置的由左向右移动的游标    high &#x3D; end  # high为序列右边末尾位置的由右向左移动的游标    while low &lt; high:        # 如果low与high未重合，high(右边)指向的元素大于等于基准元素，则high向左移动        while low &lt; high and alist[high] &gt;&#x3D; mid:            high -&#x3D; 1        alist[low] &#x3D; alist[high]  # 走到此位置时high指向一个比基准元素小的元素,将high指向的元素放到low的位置上,此时high指向的位置空着,接下来移动low找到符合条件的元素放在此处        # 如果low与high未重合，low指向的元素比基准元素小，则low向右移动        while low &lt; high and alist[low] &lt; mid:            low +&#x3D; 1        alist[high] &#x3D; alist[low]  # 此时low指向一个比基准元素大的元素,将low指向的元素放到high空着的位置上,此时low指向的位置空着,之后进行下一次循环,将high找到符合条件的元素填到此处    # 退出循环后，low与high重合，此时所指位置为基准元素的正确位置,左边的元素都比基准元素小,右边的元素都比基准元素大    alist[low] &#x3D; mid  # 将基准元素放到该位置,    # 对基准元素左边的子序列进行快速排序    quick_sort(alist, start, low - 1)  # start :0  low -1 原基准元素靠左边一位    # 对基准元素右边的子序列进行快速排序    quick_sort(alist, low + 1, end)  # low+1 : 原基准元素靠右一位  end: 最后if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    alist &#x3D; [54, 26, 93, 17, 77, 31, 44, 55, 20]    quick_sort(alist, 0, len(alist) - 1)    print(alist) # [17, 20, 26, 31, 44, 54, 55, 77, 93]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;快排原理&quot;&gt;&lt;a href=&quot;#快排原理&quot; class=&quot;headerlink&quot; title=&quot;快排原理&quot;&gt;&lt;/a&gt;快排原理&lt;/h3&gt;&lt;p&gt;在一串数组中选择任意一个数字为基准，将数组的数据和基准数据相比较，比基准大的数据在基准数字的右边，比基准小的数据在基准的左边</summary>
      
    
    
    
    <category term="Python" scheme="http://huangxiaoruipo.github.io/categories/Python/"/>
    
    
    <category term="Python" scheme="http://huangxiaoruipo.github.io/tags/Python/"/>
    
    <category term="quicksort" scheme="http://huangxiaoruipo.github.io/tags/quicksort/"/>
    
  </entry>
  
  <entry>
    <title>Python连接MySQL并执行操作</title>
    <link href="http://huangxiaoruipo.github.io/2022/04/21/python-lian-jie-mysql-bing-zhi-xing-cao-zuo/"/>
    <id>http://huangxiaoruipo.github.io/2022/04/21/python-lian-jie-mysql-bing-zhi-xing-cao-zuo/</id>
    <published>2022-04-21T11:00:10.000Z</published>
    <updated>2022-04-22T09:11:41.075Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是MySQLdb"><a href="#什么是MySQLdb" class="headerlink" title="什么是MySQLdb?"></a>什么是MySQLdb?</h3><p>MySQLdb 是用于Python链接Mysql数据库的接口，它实现了 Python 数据库 API 规范 V2.0，基于 MySQL C API 上建立的。</p><h3 id="创建SQL数据库"><a href="#创建SQL数据库" class="headerlink" title="创建SQL数据库"></a>创建SQL数据库</h3><p>在连接数据库之前确认自己已经做了以下事项：</p><ul><li>已经创建了数据库mytest</li><li>在mytest数据库中您已经创建了表 myapp_users</li><li>mytest表字段为 name, age, phone, addtime</li><li>连接数据库mytest使用的用户名为 “root” ，密码为 “123456”,你可以可以自己设定或者直接使用root用户名及其密码，Mysql数据库用户授权请使用Grant命令</li><li>在你的机子上已经安装了 Python MySQLdb 模块</li><li>熟悉SQL基本语句</li></ul><h3 id="连接SQLdb"><a href="#连接SQLdb" class="headerlink" title="连接SQLdb"></a>连接SQLdb</h3><pre class="line-numbers language-none"><code class="language-none">import MySQLdbconnect &#x3D; None  # 连接对象cursor &#x3D; None  # 游标对象try:    # 连接对象    connect &#x3D; MySQLdb.connect(host&#x3D;&#39;localhost&#39;,  # 主机地址                              user&#x3D;&#39;root&#39;,  # 账号                              password&#x3D;&#39;123456&#39;,  # 密码                              database&#x3D;&#39;mytest&#39;,  # 数据库名                              use_unicode&#x3D;True,                              charset&#x3D;&#39;utf8&#39;)  # 指定字符集    # 游标对象    cursor &#x3D; connect.cursor()  # 通过连接对象调用游标cursor()except Exception as e:    print(e)    connect.close()try:    if cursor:            result &#x3D; cursor.execute(&quot;SQL执行语句&quot;)  # 插入操作        connect.commit()  # 提交except Exception as e:    print(e)    connect.rollback()  # 回滚finally:    if cursor:        cursor.close()    if connect:        connect.close()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="创建一个数据表"><a href="#创建一个数据表" class="headerlink" title="创建一个数据表"></a>创建一个数据表</h3><p>如果数据库连接存在我们可以使用execute()方法来为数据库创建表，如下所示创建表myapp_users：</p><pre class="line-numbers language-none"><code class="language-none">import MySQLdbconnect &#x3D; None  # 连接对象cursor &#x3D; None  # 游标对象try:    # 连接对象    connect &#x3D; MySQLdb.connect(host&#x3D;&#39;localhost&#39;,  # 主机地址                              user&#x3D;&#39;root&#39;,  # 账号                              password&#x3D;&#39;123456&#39;,  # 密码                              database&#x3D;&#39;mytest&#39;,  # 数据库名                              use_unicode&#x3D;True,                              charset&#x3D;&#39;utf8&#39;)  # 指定字符集    # 游标对象    cursor &#x3D; connect.cursor()  # 通过连接对象调用游标cursor()except Exception as e:    print(e)    connect.close()try:    if cursor:    # 如果数据表已经存在使用 execute() 方法删除表。    cursor.execute(&quot;DROP TABLE IF EXISTS myapp_users&quot;)    # 创建数据表SQL语句cursor.execute(&quot;&quot;&quot;CREATE TABLE myapp_users (                                 name  CHAR(20) NOT NULL,                                 age  INT(20),                                 phone CHAR(16),                                 addtime timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT )&quot;&quot;&quot;)        connect.commit()  # 提交except Exception as e:    print(e)    connect.rollback()  # 回滚finally:    if cursor:        cursor.close()    if connect:        connect.close()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="数据库插入操作"><a href="#数据库插入操作" class="headerlink" title="数据库插入操作"></a>数据库插入操作</h3><p>对上面的数据表我们可以使用SQL INSERT向myapp_users执行插入操作</p><pre class="line-numbers language-none"><code class="language-none">import MySQLdbconnect &#x3D; None  # 连接对象cursor &#x3D; None  # 游标对象try:    # 连接对象    connect &#x3D; MySQLdb.connect(host&#x3D;&#39;localhost&#39;,  # 主机地址                              user&#x3D;&#39;root&#39;,  # 账号                              password&#x3D;&#39;123456&#39;,  # 密码                              database&#x3D;&#39;mytest&#39;,  # 数据库名                              use_unicode&#x3D;True,                              charset&#x3D;&#39;utf8&#39;)  # 指定字符集    # 游标对象    cursor &#x3D; connect.cursor()  # 通过连接对象调用游标cursor()except Exception as e:    print(e)    connect.close()try:    if cursor:            result &#x3D; cursor.execute(&quot;insert into myapp_users (name, age，phone，addtime) values (&#39;Angle&#39;, 20, 18077445566, 2022-4-21)&quot;)  # 插入操作        connect.commit()  # 提交except Exception as e:    print(e)    connect.rollback()  # 回滚finally:    if cursor:        cursor.close()    if connect:        connect.close()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用这样的代码可以往SQL中传递参数</p><pre class="line-numbers language-none"><code class="language-none">......result &#x3D; cursor.execute(&quot;insert into myapp_users (name, age，phone，addtime) values (%s, %s, %s, %s)&quot; %(name,age,phone,addtime))......<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="数据库查询操作"><a href="#数据库查询操作" class="headerlink" title="数据库查询操作"></a>数据库查询操作</h3><p>Python查询Mysql使用 fetchone() 方法获取单条数据, 使用fetchall() 方法获取多条数据。</p><ul><li><strong>fetchone():</strong> 该方法获取下一个查询结果集。结果集是一个对象</li><li>**fetchall():**接收全部的返回结果行.</li><li><strong>rowcount:</strong> 这是一个只读属性，并返回执行execute()方法后影响的行数。</li></ul><pre class="line-numbers language-none"><code class="language-none">import MySQLdbconnect &#x3D; None  # 连接对象cursor &#x3D; None  # 游标对象try:    # 连接对象    connect &#x3D; MySQLdb.connect(host&#x3D;&#39;localhost&#39;,  # 主机地址                              user&#x3D;&#39;root&#39;,  # 账号                              password&#x3D;&#39;123456&#39;,  # 密码                              database&#x3D;&#39;mytest&#39;,  # 数据库名                              use_unicode&#x3D;True,                              charset&#x3D;&#39;utf8&#39;)  # 指定字符集    # 游标对象    cursor &#x3D; connect.cursor()  # 通过连接对象调用游标cursor()except Exception as e:    print(e)    connect.close()try:    if cursor:            result &#x3D; cursor.execute(&quot;select * from myapp_users where age &gt; %s&quot; %(20))  # 查询年龄大于20的所有数据        one_ressult &#x3D; cursor.fetchone()  # 查询下一条数据        many_result &#x3D; cursor.fetchmany(5)  # 查询下五条数据        all_result &#x3D; cursor.fetchall()  # 查询剩余数据        #可以格式化输出查询结果，用剩余数据all_result 为例        for row in all_result:        name &#x3D; row[0]        age &#x3D; row[1]        phone &#x3D; row[2]        addtime &#x3D; row[3]        print(&quot;name&#x3D;%s,age&#x3D;%s,phone&#x3D;%s,addtime&#x3D;%s&quot; % (name,age,phone,addtime))        connect.commit()  # 提交except Exception as e:    print(e)    connect.rollback()  # 回滚finally:    if cursor:        cursor.close()    if connect:        connect.close()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="数据库更新操作"><a href="#数据库更新操作" class="headerlink" title="数据库更新操作"></a>数据库更新操作</h3><p>更新操作用于更新数据表的的数据，以下实例将 myapp_users表中的 name字段为 ‘Angle’ 的 age字段递增 1：</p><pre class="line-numbers language-none"><code class="language-none">import MySQLdbconnect &#x3D; None  # 连接对象cursor &#x3D; None  # 游标对象try:    # 连接对象    connect &#x3D; MySQLdb.connect(host&#x3D;&#39;localhost&#39;,  # 主机地址                              user&#x3D;&#39;root&#39;,  # 账号                              password&#x3D;&#39;123456&#39;,  # 密码                              database&#x3D;&#39;mytest&#39;,  # 数据库名                              use_unicode&#x3D;True,                              charset&#x3D;&#39;utf8&#39;)  # 指定字符集    # 游标对象    cursor &#x3D; connect.cursor()  # 通过连接对象调用游标cursor()except Exception as e:    print(e)    connect.close()try:    if cursor:            result &#x3D; cursor.execute(&quot;updata myapp_users set age &#x3D; age+1 where name &#x3D;&#39;%s&#39;&quot; %(&quot;Angle&quot;))  # 给Angle字段的age + 1        connect.commit()  # 提交except Exception as e:    print(e)    connect.rollback()  # 回滚finally:    if cursor:        cursor.close()    if connect:        connect.close()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h3><p>删除操作用于删除数据表中的数据，以下实例演示了删除数据表 myapp_users中 age大于 20 的所有数据：</p><pre class="line-numbers language-none"><code class="language-none">import MySQLdbconnect &#x3D; None  # 连接对象cursor &#x3D; None  # 游标对象try:    # 连接对象    connect &#x3D; MySQLdb.connect(host&#x3D;&#39;localhost&#39;,  # 主机地址                              user&#x3D;&#39;root&#39;,  # 账号                              password&#x3D;&#39;123456&#39;,  # 密码                              database&#x3D;&#39;mytest&#39;,  # 数据库名                              use_unicode&#x3D;True,                              charset&#x3D;&#39;utf8&#39;)  # 指定字符集    # 游标对象    cursor &#x3D; connect.cursor()  # 通过连接对象调用游标cursor()except Exception as e:    print(e)    connect.close()try:    if cursor:            result &#x3D; cursor.execute(&quot;delete from myapp_users where age &gt; %s&quot; %(20))  # 给age大于20的做删除操作        connect.commit()  # 提交except Exception as e:    print(e)    connect.rollback()  # 回滚finally:    if cursor:        cursor.close()    if connect:        connect.close()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="事务机制"><a href="#事务机制" class="headerlink" title="事务机制"></a>事务机制</h3><p>事务机制可以确保数据一致性。</p><p>事务应该具有4个属性：原子性、一致性、隔离性、持久性。这四个属性通常称为ACID特性。</p><ul><li>原子性（atomicity）。一个事务是一个不可分割的工作单位，事务中包括的诸操作要么都做，要么都不做。</li><li>一致性（consistency）。事务必须是使数据库从一个一致性状态变到另一个一致性状态。一致性与原子性是密切相关的。</li><li>隔离性（isolation）。一个事务的执行不能被其他事务干扰。即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。</li><li>持久性（durability）。持续性也称永久性（permanence），指一个事务一旦提交，它对数据库中数据的改变就应该是永久性的。接下来的其他操作或故障不应该对其有任何影响。</li></ul><p>Python DB API 2.0 的事务提供了两个方法 commit 或 rollback。</p><h3 id="一些最重要的-SQL-命令"><a href="#一些最重要的-SQL-命令" class="headerlink" title="一些最重要的 SQL 命令"></a>一些最重要的 SQL 命令</h3><ul><li><strong>SELECT</strong> - 从数据库中提取数据</li><li><strong>UPDATE</strong> - 更新数据库中的数据</li><li><strong>DELETE</strong> - 从数据库中删除数据</li><li><strong>INSERT INTO</strong> - 向数据库中插入新数据</li><li><strong>CREATE DATABASE</strong> - 创建新数据库</li><li><strong>ALTER DATABASE</strong> - 修改数据库</li><li><strong>CREATE TABLE</strong> - 创建新表</li><li><strong>ALTER TABLE</strong> - 变更（改变）数据库表</li><li><strong>DROP TABLE</strong> - 删除表</li><li><strong>CREATE INDEX</strong> - 创建索引（搜索键）</li><li><strong>DROP INDEX</strong> - 删除索引</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;什么是MySQLdb&quot;&gt;&lt;a href=&quot;#什么是MySQLdb&quot; class=&quot;headerlink&quot; title=&quot;什么是MySQLdb?&quot;&gt;&lt;/a&gt;什么是MySQLdb?&lt;/h3&gt;&lt;p&gt;MySQLdb 是用于Python链接Mysql数据库的接口，它实现了 </summary>
      
    
    
    
    <category term="Python" scheme="http://huangxiaoruipo.github.io/categories/Python/"/>
    
    
    <category term="Python" scheme="http://huangxiaoruipo.github.io/tags/Python/"/>
    
    <category term="MySQL" scheme="http://huangxiaoruipo.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Hexo框架搭建本地博客步骤（二）</title>
    <link href="http://huangxiaoruipo.github.io/2022/04/19/hexo-kuang-jia-da-jian-ben-di-bo-ke-bu-zou-er/"/>
    <id>http://huangxiaoruipo.github.io/2022/04/19/hexo-kuang-jia-da-jian-ben-di-bo-ke-bu-zou-er/</id>
    <published>2022-04-19T01:54:17.000Z</published>
    <updated>2022-04-19T11:13:02.720Z</updated>
    
    <content type="html"><![CDATA[<h3 id="关于Github的SSH-key获取"><a href="#关于Github的SSH-key获取" class="headerlink" title="关于Github的SSH-key获取"></a>关于Github的SSH-key获取</h3><p>接上一个文章内容，要再本地提交代码需要Github的权限，我们直接使用账户密码的话，并不安全，使用SSH-key可以免密登录，解决服务器-本地连接的问题。</p><ul><li>Git Bash 内输入</li></ul><pre class="line-numbers language-none"><code class="language-none">git config --global user.name &quot;usernmae&quot; &#x2F;&#x2F;你的用户名git config --global user.email  &quot;youremail&quot; &#x2F;&#x2F;你的注册邮箱<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>接着获取密钥</li></ul><pre class="line-numbers language-none"><code class="language-none">ssh-keygen -t rsa -C github邮件地址<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><p>每次提示敲一次回车，GIit Bash出现一个点阵的方框信息就表示成功</p></li><li><p>这个操作会在<code>C:\Users\LENOVO\.ssh</code>生成一个密钥文件，打开<code>id_rsa.pub</code>复制里面的内容</p></li><li><p>在下图所示Github设置里面密钥，保存</p></li><li><img src="/2022/04/19/hexo-kuang-jia-da-jian-ben-di-bo-ke-bu-zou-er/image-20220419114225057.png" alt="image-20220419114225057" style="zoom:67%;"></li><li><p>在Git Bash检测设置是否成功</p></li></ul><pre class="line-numbers language-none"><code class="language-none">ssh -T git@github.com &#x2F;&#x2F;输入这句命令，之后提示yes&#x2F;no的话输入 yes <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>最后有下图提示说明成功</li></ul><p><img src="/2022/04/19/hexo-kuang-jia-da-jian-ben-di-bo-ke-bu-zou-er/image-20220419114606789.png" alt="成功了"></p><h3 id="使用Hexo搭建博客"><a href="#使用Hexo搭建博客" class="headerlink" title="使用Hexo搭建博客"></a>使用Hexo搭建博客</h3><ul><li>在你心仪的地方新建一个用来存放将来博客各种代码文件的文件夹</li><li>进入文件夹，右键在文件夹下打开Git Bash</li><li>初始化Hexo</li></ul><pre class="line-numbers language-none"><code class="language-none">Hexo init MyBlogcd MyBlognpm install<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>执行完毕会生成下方文件夹目录（以下搬运自HEXO<a href="https://hexo.io/zh-cn/docs/setup">官方文档</a>）</li></ul><pre class="line-numbers language-none"><code class="language-none">.├── _config.yml├── package.json├── scaffolds├── source|   ├── _drafts|   └── _posts└── themes<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="config-yml"><a href="#config-yml" class="headerlink" title="_config.yml"></a>_config.yml</h4><ul><li>网站的 <a href="https://hexo.io/zh-cn/docs/configuration">配置</a> 信息，您可以在此配置大部分的参数。</li></ul><h4 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a>package.json</h4><ul><li>应用程序的信息。<a href="https://ejs.co/">EJS</a>, <a href="http://learnboost.github.io/stylus/">Stylus</a> 和 <a href="http://daringfireball.net/projects/markdown/">Markdown</a> renderer 已默认安装，您可以自由移除。</li></ul><pre class="line-numbers language-none"><code class="language-none">package.json&#123;  &quot;name&quot;: &quot;hexo-site&quot;,  &quot;version&quot;: &quot;0.0.0&quot;,  &quot;private&quot;: true,  &quot;hexo&quot;: &#123;    &quot;version&quot;: &quot;&quot;  &#125;,  &quot;dependencies&quot;: &#123;    &quot;hexo&quot;: &quot;^3.8.0&quot;,    &quot;hexo-generator-archive&quot;: &quot;^0.1.5&quot;,    &quot;hexo-generator-category&quot;: &quot;^0.1.3&quot;,    &quot;hexo-generator-index&quot;: &quot;^0.2.1&quot;,    &quot;hexo-generator-tag&quot;: &quot;^0.2.0&quot;,    &quot;hexo-renderer-ejs&quot;: &quot;^0.3.1&quot;,    &quot;hexo-renderer-stylus&quot;: &quot;^0.3.3&quot;,    &quot;hexo-renderer-marked&quot;: &quot;^0.3.2&quot;,    &quot;hexo-server&quot;: &quot;^0.3.3&quot;  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="scaffolds"><a href="#scaffolds" class="headerlink" title="scaffolds"></a>scaffolds</h4><ul><li><p><a href="https://hexo.io/zh-cn/docs/writing">模版</a> 文件夹。当您新建文章时，<code>Hexo </code>会根据 <code>scaffold</code> 来建立文件。</p></li><li><p>Hexo的模板是指在新建的文章文件中默认填充的内容。例如，如果您修改<code>scaffold/post.md</code>中的<code>Front-matter</code>内容，那么每次新建一篇文章时都会包含这个修改。</p></li></ul><h4 id="source"><a href="#source" class="headerlink" title="source"></a>source</h4><ul><li>资源文件夹是存放用户资源的地方。除 <code>_posts</code> 文件夹之外，开头命名为 <code>_</code> (下划线)的文件 &#x2F; 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 <code>public</code> 文件夹，而其他文件会被拷贝过去。</li></ul><h4 id="themes"><a href="#themes" class="headerlink" title="themes"></a>themes</h4><ul><li><a href="https://hexo.io/zh-cn/docs/themes">主题</a> 文件夹。Hexo 会根据主题来生成静态页面。</li></ul><h3 id="让我们来生成第一个Hexo博客站点"><a href="#让我们来生成第一个Hexo博客站点" class="headerlink" title="让我们来生成第一个Hexo博客站点"></a>让我们来生成第一个Hexo博客站点</h3><pre class="line-numbers language-none"><code class="language-none">hexo g &#x2F;&#x2F;hexo generate简写，根据模板，拉取资源文件渲染静态网页hexo s &#x2F;&#x2F;hexo server简写，在本地运行服务<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>在浏览器，本地访问 <a href="http://127.0.0.1:4000/">http://127.0.0.1:4000</a> 端口，如果被占用中断运行服务厚更换到5000端口</li></ul><pre class="line-numbers language-none"><code class="language-none">hexo s -p 5000<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="部署到Github个人主页"><a href="#部署到Github个人主页" class="headerlink" title="部署到Github个人主页"></a>部署到Github个人主页</h3><ul><li>安装Hexo一键部署工具包</li></ul><pre class="line-numbers language-none"><code class="language-none">npm install hexo-deployer-git --save<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>根目录下的<code>_config.yml</code>文件deploy里添加以下设置</li></ul><pre class="line-numbers language-none"><code class="language-none">deploy:  type: git  repo: https:&#x2F;&#x2F;github.com&#x2F;你的用户名&#x2F;你的用户名.github.io &#x2F;&#x2F;即注册仓库的名称  branch: main &#x2F;&#x2F;新版本特性使用Main<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>一切就绪，Git Bash输入以下命令</li></ul><pre class="line-numbers language-none"><code class="language-none">hexo cleanhexo ghexo d &#x2F;&#x2F;将代码托管到Github仓库<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>有可能会需要输入 name password，分别输入注册邮箱和密码即可。</li><li>成功后在浏览器输入网址</li></ul><pre class="line-numbers language-none"><code class="language-none">https:&#x2F;&#x2F;仓库名.github.io&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>如果部署失败可以参考下面解决方法，这是我第一次部署的时候踩到的各种坑。</li></ul><h3 id="关于部署不上的解决方法"><a href="#关于部署不上的解决方法" class="headerlink" title="关于部署不上的解决方法"></a>关于部署不上的解决方法</h3><ul><li>其一，<code>Github</code> 的服务器部署在海外，连接比较慢，多测试几次</li><li>其二，恰好当时网址被墙了，设置以下host再试</li><li>其三，还是登录不上的话再去设置一个<code>Personal access tokens</code>来作为登录密钥</li><li>其四，启用通过 HTTPS 的 SSH 连接，在<code>~/.ssh/config</code>编辑文件，设置如下</li></ul><pre class="line-numbers language-none"><code class="language-none">Host github.comHostname ssh.github.comPort 443User git<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>再次连接github.com测试是否连接上</li></ul><pre class="line-numbers language-none"><code class="language-none">$ ssh -T git@github.com&gt; Hi username! You&#39;ve successfully authenticated, but GitHub does not&gt; provide shell access.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="网站托管成功"><a href="#网站托管成功" class="headerlink" title="网站托管成功"></a>网站托管成功</h3><ul><li>到现在我们的博客就部署完成了，但是自带界面是怎么能满足我们对美的追求呢，下篇会介绍以下怎么使用各位大佬现成的主题对个人博客美化、修改出一个有个人特色的一个网站。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;关于Github的SSH-key获取&quot;&gt;&lt;a href=&quot;#关于Github的SSH-key获取&quot; class=&quot;headerlink&quot; title=&quot;关于Github的SSH-key获取&quot;&gt;&lt;/a&gt;关于Github的SSH-key获取&lt;/h3&gt;&lt;p&gt;接上一个文章</summary>
      
    
    
    
    <category term="HEXO" scheme="http://huangxiaoruipo.github.io/categories/HEXO/"/>
    
    
    <category term="HEXO" scheme="http://huangxiaoruipo.github.io/tags/HEXO/"/>
    
    <category term="Node.js" scheme="http://huangxiaoruipo.github.io/tags/Node-js/"/>
    
    <category term="npm" scheme="http://huangxiaoruipo.github.io/tags/npm/"/>
    
    <category term="Git" scheme="http://huangxiaoruipo.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Hexo框架搭建本地博客步骤（一）</title>
    <link href="http://huangxiaoruipo.github.io/2022/04/16/hexo-kuang-jia-da-jian-ben-di-bo-ke-bu-zou-yi/"/>
    <id>http://huangxiaoruipo.github.io/2022/04/16/hexo-kuang-jia-da-jian-ben-di-bo-ke-bu-zou-yi/</id>
    <published>2022-04-16T15:54:04.000Z</published>
    <updated>2022-04-19T07:20:26.039Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p> 本系列主要是讲怎么去安装 <em>Node.js</em> 、<em>Hexo</em> 、<em>Git</em> 、<em>配置GitHub仓库</em>、以及新建第一个 <em>GitHub Pages</em>页面。</p><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><h3 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a>安装Node.js</h3><ul><li><p>前往<a href="http://nodejs.cn/">Node.js</a>中文网站，根据Windows版本选择合适的安装包，根据中文文档安装Node环境</p></li><li><p>打开一个新的PowerShell窗口,输入下面命令检查是否安装成功</p><pre class="line-numbers language-none"><code class="language-none">npm -vnode -v<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>成功会显示当前安装环境的版本</p></li></ul><h3 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h3><ul><li><p>进入官网下载软件并根据网络教程安装</p></li><li><p>打开一个新的PowerShell窗口,输入下面命令检查是否安装成功</p></li></ul><pre class="line-numbers language-none"><code class="language-none">git --version<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="修改npm源"><a href="#修改npm源" class="headerlink" title="修改npm源"></a>修改npm源</h3><ul><li>由于官方 NPM 源下载 包的速度太慢，所以我们将 NPM 的源 替换成 淘宝源：</li></ul><pre class="line-numbers language-none"><code class="language-none">npm config set registry https:&#x2F;&#x2F;registry.npm.taobao.org<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h3><ul><li>Git-bash输入</li></ul><pre class="line-numbers language-none"><code class="language-none">npm install hexo-cli -g<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><a href="https://hexo.io/zh-cn/docs/">也可以参考官方文档</a>配置</li></ul><h3 id="配置GitHub仓库"><a href="#配置GitHub仓库" class="headerlink" title="配置GitHub仓库"></a>配置GitHub仓库</h3><ul><li><p>注册一个GitHub账号，创建一个仓库用来托管代码</p></li><li><p><img src="/2022/04/16/hexo-kuang-jia-da-jian-ben-di-bo-ke-bu-zou-yi/image-20220416223415359.png"></p></li><li><p><img src="/2022/04/16/hexo-kuang-jia-da-jian-ben-di-bo-ke-bu-zou-yi/image-20220416223551516.png"></p></li></ul><h2 id="环境搭建完成"><a href="#环境搭建完成" class="headerlink" title="环境搭建完成"></a>环境搭建完成</h2><p>到这里，除了GitHub的SSH Key 配置已经基本完成了，优秀的教程很多可以参考网上的教程，今天很晚了，明天继续写SSH Key 配置。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;&lt;p&gt; 本系列主要是讲怎么去安装 &lt;em&gt;Node.js&lt;/em&gt; 、&lt;em&gt;Hexo&lt;/em&gt; 、&lt;em&gt;Git&lt;/em&gt; 、&lt;</summary>
      
    
    
    
    <category term="HEXO" scheme="http://huangxiaoruipo.github.io/categories/HEXO/"/>
    
    
    <category term="HEXO" scheme="http://huangxiaoruipo.github.io/tags/HEXO/"/>
    
    <category term="Node.js" scheme="http://huangxiaoruipo.github.io/tags/Node-js/"/>
    
    <category term="npm" scheme="http://huangxiaoruipo.github.io/tags/npm/"/>
    
    <category term="Git" scheme="http://huangxiaoruipo.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>我的第一个博客</title>
    <link href="http://huangxiaoruipo.github.io/2022/04/15/wo-de-di-yi-ge-bo-ke/"/>
    <id>http://huangxiaoruipo.github.io/2022/04/15/wo-de-di-yi-ge-bo-ke/</id>
    <published>2022-04-15T09:04:41.000Z</published>
    <updated>2022-04-16T13:28:46.910Z</updated>
    
    <content type="html"><![CDATA[<h3 id="为什么要做自己的博客呢？"><a href="#为什么要做自己的博客呢？" class="headerlink" title="为什么要做自己的博客呢？"></a>为什么要做自己的博客呢？</h3><p>最根本的原因是林檎大佬说做一个个人博客网站非常有用，记录自己的学习心得、有用的代码块、时间长了也是个人简历说明的一种。正好本人对写作也充满兴趣，平时忙于工作又没时间去写点东西，趁着这个机会也把想做的事情做出来吧。</p><h3 id="选用什么方式去部署个人博客？"><a href="#选用什么方式去部署个人博客？" class="headerlink" title="选用什么方式去部署个人博客？"></a>选用什么方式去部署个人博客？</h3><p>一开始考虑的是仿照优秀的博客，使用原生代码去写自己的博客网站，在搭建网站的过程中去学习前端的技术。不过在做了两天的准备后，发现一个完善的博客框架和好看的前端页面是我目前做不出来的，大受打击。最终选择使用了<a href="https://hexo.io/zh-cn/">Hexo</a>+<a href="https://github.com/">GitHub</a>来部署个人网站。</p><p>Hexo正如它所说的一样是如此的快速、高效、简洁。基于Node.js的优点，Hexo很快的将本地Markdown页面渲染成网页，另外有大量的插件可以使用，支持一键部署；当然，最重要的还是它的主题很多，使用起来很方便，只需要根据说明文档修改就能制作出来一具有个人特色的个人博客。</p><h3 id="成果及感悟"><a href="#成果及感悟" class="headerlink" title="成果及感悟"></a>成果及感悟</h3><p>搭建个人博客的过程中遇到了各种奇奇怪怪的问题，把人折腾的够呛，不过在经历了一天的不懈努力，大体的框架终于搭建出来了！！！！撒花~！</p><p>本博客使用到的资源环境如下：</p><ul><li>操作系统：Windows 10</li><li>Node,js</li><li>Hexo</li><li>Git</li><li>一个GitHub账号</li></ul><p>成品展示~</p><p><img src="/2022/04/15/wo-de-di-yi-ge-bo-ke/image-20220416212749962.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;为什么要做自己的博客呢？&quot;&gt;&lt;a href=&quot;#为什么要做自己的博客呢？&quot; class=&quot;headerlink&quot; title=&quot;为什么要做自己的博客呢？&quot;&gt;&lt;/a&gt;为什么要做自己的博客呢？&lt;/h3&gt;&lt;p&gt;最根本的原因是林檎大佬说做一个个人博客网站非常有用，记录自己</summary>
      
    
    
    
    <category term="HEXO" scheme="http://huangxiaoruipo.github.io/categories/HEXO/"/>
    
    
    <category term="HEXO" scheme="http://huangxiaoruipo.github.io/tags/HEXO/"/>
    
    <category term="matery" scheme="http://huangxiaoruipo.github.io/tags/matery/"/>
    
  </entry>
  
</feed>
