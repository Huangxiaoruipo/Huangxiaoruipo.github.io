<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>KITOHUANG</title>
  
  <subtitle>每日一言</subtitle>
  <link href="http://huangxiaoruipo.github.io/atom.xml" rel="self"/>
  
  <link href="http://huangxiaoruipo.github.io/"/>
  <updated>2022-11-06T06:15:51.489Z</updated>
  <id>http://huangxiaoruipo.github.io/</id>
  
  <author>
    <name>KITOHUANG</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>克苏鲁</title>
    <link href="http://huangxiaoruipo.github.io/2022/11/06/ke-su-lu/"/>
    <id>http://huangxiaoruipo.github.io/2022/11/06/ke-su-lu/</id>
    <published>2022-11-06T04:44:12.000Z</published>
    <updated>2022-11-06T06:15:51.489Z</updated>
    
    <content type="html"><![CDATA[<h4 id="克苏鲁"><a href="#克苏鲁" class="headerlink" title="克苏鲁"></a>克苏鲁</h4><h6 id="Cthulhu"><a href="#Cthulhu" class="headerlink" title="Cthulhu"></a><strong>Cthulhu</strong></h6><p>克苏鲁（Cthulhu）在每个作家的作品里都是不同的存在，每位作家对于他们笔下的克苏鲁都有不同的诠释。经过一代又一代作家的创作，最终是形成了我们现在所看到的克苏鲁神话体系划分—“旧日支配者”，简称为旧神。</p><p>克苏鲁在<em>霍华德·菲利普·洛夫克拉夫特</em>所创造的克苏鲁神话体系中，虽然不是地位最高的神，但是他是最广为人知的一个旧神形象，也是克苏鲁神话的代表。</p><img src="/2022/11/06/ke-su-lu/%E5%85%8B%E8%8B%8F%E9%B2%81/image-20221106125222436.png" alt="image-20221106125222436" style="zoom:80%;"><p>克苏鲁的全称为“伟大之克苏鲁(Great Cthulhu)”，沉睡之神，拉莱耶之主，在奥古斯特·威廉·德雷斯为克苏鲁神话构建的元素论中其为象征“水”的存在之一。 </p><h6 id="外观描述"><a href="#外观描述" class="headerlink" title="外观描述"></a><strong>外观描述</strong></h6><p><em>“**它刻画的是一个怪物，隐约带有人的轮廓，却长着一个像八爪鱼似的有众多触须的脑袋，身体像是覆着鳞片的胶状物，长着巨型的脚爪，身后还有一对狭长的翅膀</em> *……<strong>它有着臃肿肥胖的身体</strong>…….<strong>淌着粘液，巨大的绿色身躯蹒跚着从那黑暗的开口中拥挤而出，走进人们的视野</strong>……<strong>好似一座山岭行走于天地之间。</strong>”*</p><p>——H.P.洛夫克拉夫特《克苏鲁的呼唤》</p><p>作为旧日支配者的一员，克苏鲁的形象带有人类、八爪鱼、蝙蝠的特征，他全身绿色，身材巨大好像一座高山。肥胖臃肿的身体上覆盖着鳞片，四肢是巨大的利爪，背后还有一对与体型不相称的翅膀。</p><p> 头部则是长着有无数的章鱼触须一样的柔软触手，原文是 “用有些夸张的想象力将它看做一只章鱼、一条龙与一个歪曲夸张了的人同时杂糅在一起产生的形象或许能较为忠实地反映它的神髓“，作者将克苏鲁的外形比作章鱼和西方龙的集合体，头部酷似鱿鱼。</p><img src="/2022/11/06/ke-su-lu/%E5%85%8B%E8%8B%8F%E9%B2%81/image-20221106125615909.png" alt="克苏鲁头部"><img src="/2022/11/06/ke-su-lu/%E5%85%8B%E8%8B%8F%E9%B2%81/image-20221106125639173.png" alt="克苏鲁头部" style="zoom:80%;"><p>大概就是以上的长相，我们也笑称为拉<em><strong>莱耶海鲜之主</strong></em></p><img src="/2022/11/06/ke-su-lu/%E5%85%8B%E8%8B%8F%E9%B2%81/image-20221106125818562.png" alt="这位先生，了解一下我们伟大的天父" style="zoom:80%;"><h6 id="眷族和崇拜者"><a href="#眷族和崇拜者" class="headerlink" title="眷族和崇拜者"></a>眷族和崇拜者</h6><p>克苏鲁的直属眷族在我所知道的应该只有<strong>星之眷族</strong>(Star-Spawn of Cthulhu)</p><p><em><strong>“他们安息在拉莱耶的石窟中，由克苏鲁强大的魔咒保护，直到群星与地球都做好准备；那时，他们将辉耀返生。</strong>”</em></p><p>——H.P.洛夫克拉夫特《克苏鲁的呼唤》</p><p>他们是克苏鲁的仆从，外形旧神巨大章鱼，除了没有翅膀手脚外，他们长的和克苏鲁十分相似。星之眷族与克苏鲁在同一时间降临地球，他们自遥远的时空连续体之外，他们是由比我们的宇宙本身更广泛的物质组成，能够变形和重组躯体。</p><img src="/2022/11/06/ke-su-lu/%E5%85%8B%E8%8B%8F%E9%B2%81/image-20221106133209430.png" alt="星之眷族" style="zoom:80%;"><p><em>“<strong>以海底的伊哈</strong>·<strong>恩斯雷之地及其居民之名，赞颂</strong>‘<strong>统治一切者</strong>’<strong>。以</strong>‘<strong>基什之印</strong>’<strong>及一切服从此印者之名，赞颂制印者。以</strong>‘<strong>通往耶之门</strong>’<strong>及一切使用此门者</strong>——<strong>即已行者与将来者之名，赞颂位于门彼方者。以</strong>‘<strong>必将来临者</strong>’<strong>之名</strong>……<strong>在永恒的宅邸拉莱耶，长眠的</strong>克苏鲁<strong>候汝入梦。</strong>”</em></p><p>——《拉莱耶文本》</p><p><em>“<strong>我们在海中的克苏鲁，愿你的名受显扬，愿你的国来临，愿你的旨意奉行在拉莱耶，如同在伊哈</strong>·<strong>恩斯雷。</strong>”</em></p><p>——《死灵之书》</p><p>在《拉莱耶文本》中提到，克苏鲁沉睡在永恒的宅邸拉莱耶里，而拉莱耶之城位于海底深渊。在沉没于深渊的拉莱耶之城中，克苏鲁的梦境会影响到外界生物，<em><strong>“必将来临者”</strong></em>是指代被克苏鲁影响到的人类或者是其他有智慧生命。</p><p>这些生灵受到克苏鲁以及星之眷族残留精神力的影响，要么就是被星之眷族同化成傀儡，要么就是获得神秘学的知识成为克苏鲁的仆从。</p><p>这些眷族遍布世界各地，中国的群山之间、埃雷姆的沙土之下、格陵兰岛的冰川之中、南美的安第斯山脉内部以及罗德岛附近的某个无名建筑脚下深处的海边洞穴里都有他们的痕迹。</p><p> 他们通过精神讯息招募<em><strong>克苏鲁教团</strong></em>的成员，沉寂在黑暗之中，为迎接他们伟大的克苏鲁回归作出准备。</p><p><em>注：之前在视频文案中提到，<strong>“门之彼方者”</strong>是受到克苏鲁影响的人类，这个是我写错了，克苏鲁的眷属们赞颂的是<strong>伟大的克苏鲁</strong>，克苏鲁沉睡在拉莱耶之城的宫殿里，有一座石制大门，克苏鲁就沉睡在门的后面。</em></p><h6 id="权柄及其对世界的影响"><a href="#权柄及其对世界的影响" class="headerlink" title="权柄及其对世界的影响"></a>权柄及其对世界的影响</h6><p><em><strong>他以一种诗意得有些古怪的方式谈论自己的梦境；让我在令人恐惧的生动中看见那座由黏滑的绿色石头修建起来的潮湿城市——那座，按他那古怪的说辞，几何学完全错乱的城市——同时，还让我在充满恐惧的期待中听见了那从地底传来的、永不停歇、几乎像是精神感应般的呼唤：</strong></em></p><p><em><strong>“Cthulhu fhtagn”</strong></em>，<em><strong>“Cthulhu fhtagn”</strong></em>。</p><p>*——**H.P.*<em>洛夫克拉夫特《克苏鲁的呼唤》</em></p><p><em><strong>这些梦境，以及它们在他潜意识里留下的痕迹，深刻地影响了他的艺术，而且他还向我展示了一件病态而恐怖的塑像——这尊塑像轮廓，以及它所能表现出的邪恶暗示，让我几乎不由自主地战栗起来。</strong></em></p><p>*——**H.P.*<em>洛夫克拉夫特《克苏鲁的呼唤》</em></p><p>克苏鲁称为为睡梦之神，拥有影响人类梦境的能力。他强大的精神力能够像世界任何角落传播可怕的噩梦，能够阅读任何生物的思维，并且像他们施加同化影响。智慧底下的生物会轻而易举被控制，人类能够通过意志干扰被同化的进程，但是一旦这种同化失效，被施加影响者将会直接面临克苏鲁的吞噬，变成一具傀儡。</p><p>另外，被克苏鲁梦境所链接的人类，会被梦境的内容所影响，通常被影响到的便是他们的艺术创作能力。梦境链接者从睡梦中醒来，并受到梦境驱使去记录、去创作梦境中所感受到的内容——如同深渊一般的恐怖雕塑。</p><p>在诸多世纪过去，对克苏鲁的崇拜者形成了庞大的教派，遍及世界的每个角落。关于教派以后有机会再细说。</p><p>他们对被克苏鲁影响到的人类非常友好，认为这些人能宣扬来自伟大存在的思想回音，而实际上，长期受到梦魇侵蚀的人类最终会因为长期接触到不可名状的形象和克苏鲁那无可言述的思想而发疯乃至自杀。</p><p><em><strong>按照他们的说法，他们崇拜旧日支配者。早在地球尚且年轻的时候，这些存在就从天而降，并且在一切人类出现之前就已生活在这里。而现在，旧日支配者已经死了，埋在大地深处，沉在海底深渊；但它们死亡的尸体通过梦境将自己的秘密告诉了第一批人类，于是这些人成立了一个永不消亡的教派。他们就是那个教派，囚犯们说它一直存在而且将永远存在，它会隐匿在世界各处的偏僻荒野与黑暗角落里。直到大祭司克苏鲁自它那水底雄伟城市中的黑暗宅邸里崛起，统治整个世界。当群星都做好准备，他将会呼唤，而秘密教派则一直都在等待着解放它的那天。</strong></em></p><p>*——**H.P.*<em>洛夫克拉夫特《克苏鲁的呼唤》</em></p><p>克苏鲁从在人类出现之前就存在地球，这也是前文提到克苏鲁又被称为“旧日之神”的原因。《克苏鲁的呼唤》这篇故事里表示，当群星归位之时，沉寂在深海的拉莱耶之城将会在波涛中冉冉升起，教徒们将会一起打开背后沉睡着克苏鲁的拉莱耶之门，那时候在黑暗中长眠许久的拉莱耶之主、沉睡之神、伟大的克苏鲁将会在荣耀中复生，重新支配世间。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;克苏鲁&quot;&gt;&lt;a href=&quot;#克苏鲁&quot; class=&quot;headerlink&quot; title=&quot;克苏鲁&quot;&gt;&lt;/a&gt;克苏鲁&lt;/h4&gt;&lt;h6 id=&quot;Cthulhu&quot;&gt;&lt;a href=&quot;#Cthulhu&quot; class=&quot;headerlink&quot; title=&quot;Cthulhu</summary>
      
    
    
    
    <category term="克系神话" scheme="http://huangxiaoruipo.github.io/categories/%E5%85%8B%E7%B3%BB%E7%A5%9E%E8%AF%9D/"/>
    
    
    <category term="旧神" scheme="http://huangxiaoruipo.github.io/tags/%E6%97%A7%E7%A5%9E/"/>
    
  </entry>
  
  <entry>
    <title>回忆打工人一个难忘的周末</title>
    <link href="http://huangxiaoruipo.github.io/2022/11/05/wang-bu-diao-de-gong-ye-yuan/"/>
    <id>http://huangxiaoruipo.github.io/2022/11/05/wang-bu-diao-de-gong-ye-yuan/</id>
    <published>2022-11-05T12:41:55.000Z</published>
    <updated>2022-11-05T13:31:59.153Z</updated>
    
    <content type="html"><![CDATA[<p>偶尔晚上睡觉的时候，会想着其实原来也挺好，为什么我会选择离开，一成不变的安稳生活也能凑合着过。</p><p>想着想着，原来深夜加班也没有这么难熬了，我能一个人独享晚上的宁静，隔着玻璃传来车间若有若无的机械轰鸣，从工位踩着滑步溜到饮水机打一杯满满的免费纯净水，透过窗外看远山在夜色中若隐若现，脚下的路边几盏灯在黑暗中孤零零的立着。</p><p>固定单休的生活会让人觉得特别的累，回到宿舍倒头就睡，或者就是<a href="https://www.zhihu.com/search?q=%E6%8A%A5%E5%A4%8D%E6%80%A7%E7%86%AC%E5%A4%9C&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2641561906%7D">报复性熬夜</a>看书追剧，一直到快天亮才睡觉。醒来已经是中午十一二点，想到第二天又要上班，强打精神去楼下对付口午饭。</p><p>加工车间对面的食堂一般都是灰蒙蒙的，被建筑挡住了阳光，门口旁边是泔水桶，食物腐败的酸臭味混杂着机油和铁锈的味道，让人不自觉精神一振。地板场面的包浆有些粘，穿着休闲鞋走在上面发出吱吱的响声，我不禁加快了脚步，走到窗口打饭。</p><p>这个时候一般都只会有炸得过头发苦的带鱼和皮下一层油脂的白切鸭，运气好的时候偶尔能有烧鸭，今天来晚了，并没有烧鸭。直到我离开都想不明白的是，为什么烧鸭的脖子永远卖不完，给到我碗里永远都是一块一块的鸭脖。我发散着思绪，一边穿过狭窄的过道，找到了一处面向墙单排座位，还有空位，这是我经常坐的位置。只有早餐我会选择坐在窗边，阳光照射在桌面上，能让我觉周围变得明亮起来。</p><p>后勤部门花高价聘请的厨师技艺确实达到了常人不能达到的高度，硬要形容就是三四层楼那么高，每顿饭都让我觉得记忆犹新，时隔一年想起来依旧忘不掉那个味道。带鱼和白切鸭，两者的特殊腥味刺激着味蕾，不禁让我的胃有点抽搐，赶紧扒几口米饭，梗着脖子勉强吞咽下去。这个米饭不能多吃，我消化不掉，每次吃多点儿都觉得胃里面有东西撑着，一直不舒服。</p><p>所以我一般都是吃点儿饭再喝几口菜汤。往炒完菜的锅里倒入开水，搅拌均匀，搁上几片择菜剩下的菜叶子，最后撒上几粒葱花。虽然卖相不好，但胜在实惠，少油少盐，喝多了也不会影响健康，关键还免费。</p><p>吃完午饭带上一瓶可乐，本想回宿舍睡觉，养好精神迎接第二天的工作。但经常的时候会接到电话，有一些紧急的图纸需要深化出图，或者车间生产遇到一些参数不清楚需要解决，这时候往往一去就是一下午。不过也习惯了，毕竟运气差的时候，有同事休假，他那份工作我也得处理，那上午也没有休息时间。</p><p>终于结束了周日的工作，骑上我从别人手里倒腾来的破电动车准备出去吃个晚饭。厂区距离有人开店的地方有些距离，不是什么商业区，就原来一条土路陆续有人在旁边搭建房子开店发展起来的一条街道，经过这么多年的建设也逐渐有了人烟。</p><p>许久不出一趟园区大门，看到三角街的变化让我有些惊讶，原来只有零星几家快餐店的街道上，不知道什么时候新开张了两家奶茶店，这两家店连在一起，旁边是美容店，对面也是一家新开张的烘焙店，这让我十分惊喜。毕竟在这种偏僻的小镇驻扎了许久，好久没见过城市的霓虹，有些城里新鲜的玩意传到这里，我能感觉到我并不是去到了非洲某个小国做基建。</p><p>非洲我是没去过的，不过很多班长去过，闲聊的时候常常会和我聊起他们在非洲修建厂房的光荣岁月。我差点是去了泰国，毕业的时候原来是签的项目部，那时候没有出国的经历，一直想去看看，然后特意问了国外项目的情况。还好后来没有去项目，抽调到车间搞生产管理，不然我也是那一周没到就提着项目的小红桶跑路的人员之一了。</p><p>项目上真的又苦又累的，我不能理解为什么会有人在项目上一呆就是十几二十年。可是最近听说，原来在项目上早早离职的同期同学，现在都过的还不过，工作稳定，工资照发，我在想，当时也是去项目，然后早早从这行脱身，是不是现在也能成为一名专业技术能力比较强的科研工作者呢。</p><p>所谓<em><strong>福兮祸所倚，祸兮福所依</strong></em>就是如此了吧。</p><p>草草吃完饭，也没什么需要忙的事情，就骑车车慢慢的在路上走，过了立秋天黑的比较快，路边的路灯时好时坏，可能有领导来检查园区才会打开所有的路灯吧。</p><p>不过我觉得也不需要路灯，些许星光衬映出两旁的灌木，路很平整，不会掉进坑里。因为人烟稀少，附近都还保持着原始的生态环境，幽幽虫鸣显得更加安静。在此刻没有机械金属碰撞的声音，没有发动机的轰鸣，仅有我和自然万物，共享夜色。身与心在长久的束缚中得到了解脱，心神得到了升华，升起于夜空，越飘越远，像是要登上天边的星星……</p><p>今天的夜晚更让人心烦意乱，画不完的图纸，赶不完的工期，扯不完的皮，甩不掉的锅，像潮水一般像我袭来，感觉这个周末我像是越休息越累了呢。</p><p>有时候我觉得肉体就是一个牢笼，我被困在了一个铁皮罐子里，他把真正的我关在了里面，所以一切都显得被笼罩上了薄纱，看的不清切，触摸到的也不合预期。周围的人说话像是在嗡嗡叫，晃来晃去的身影让人觉得天旋地转，键盘声，鼠标声，消息提示声，越来越急促，最后嗡的一下什么也听不见了。我坐在工位上发呆，不知道什么时候睡过去了，潜意识中，我感觉到我的心脏跳动越来越慢，越来越轻，接着我呼吸骤停。与此同时，巨大的恐怖感像我袭来，我猛的一下惊醒，心脏砰砰砰狂跳不止，好久才平息，不知道什么时候已经出了一身冷汗。</p><p>后来安静下来的时候，我就能感觉到我的心脏在身体里跳动，脉搏伴随着血管收缩扩张，沉重的心跳声传到神经深处。严重的时候，难受到怎么也睡不着。真是个奇妙的现象。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;偶尔晚上睡觉的时候，会想着其实原来也挺好，为什么我会选择离开，一成不变的安稳生活也能凑合着过。&lt;/p&gt;
&lt;p&gt;想着想着，原来深夜加班也没有这么难熬了，我能一个人独享晚上的宁静，隔着玻璃传来车间若有若无的机械轰鸣，从工位踩着滑步溜到饮水机打一杯满满的免费纯净水，透过窗外看远山</summary>
      
    
    
    
    <category term="随想录" scheme="http://huangxiaoruipo.github.io/categories/%E9%9A%8F%E6%83%B3%E5%BD%95/"/>
    
    
    <category term="每日随笔" scheme="http://huangxiaoruipo.github.io/tags/%E6%AF%8F%E6%97%A5%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>漫长的失联以后想说的话</title>
    <link href="http://huangxiaoruipo.github.io/2022/11/05/man-chang-de-shi-lian-yi-hou-xiang-shuo-de-hua/"/>
    <id>http://huangxiaoruipo.github.io/2022/11/05/man-chang-de-shi-lian-yi-hou-xiang-shuo-de-hua/</id>
    <published>2022-11-04T16:27:17.000Z</published>
    <updated>2022-11-05T06:44:43.652Z</updated>
    
    <content type="html"><![CDATA[<h4 id="关于失联很久以后…"><a href="#关于失联很久以后…" class="headerlink" title="关于失联很久以后…"></a>关于失联很久以后…</h4><p>​很长一段时间都没更新HEXO的博客了，电脑被雷击穿主板以后，因为没布局服务器，也没办法更新。</p><p>​另外一个很重要的原因，近段时间来发生了很多很多的事情，我失去了前进的方向。</p><p>​或许这样说会显得很矫情，可我现在确实是在思考人生。</p><p>​2022年5月22日，我从钢结构公司离开，这是我毕业以来一直从事的工作。虽然我认为这份工作并不是我理想的那样，也不会从事多长时间，但我很热爱这份工作。</p><p><strong>即使他很枯燥，每天重复一样的内容；</strong></p><p><strong>即使他很繁琐，需要处理许多文件、数据；</strong></p><p><strong>即使他很辛苦，一直到我从公司离开都在加班；</strong></p><p><strong>即使他发薪不规律，每年都延迟至少两个月发薪</strong></p><p><strong>即使他需要应酬，我一喝酒就会胃疼</strong></p><p><strong>即使缺少睡眠，我睡眠条件要求很高，有点不合适就睡不了觉</strong></p><p><strong>…………..</strong></p><p>​我却仍然对这份工作保持着最大的敬意，用百分之一百二十的精力和态度去对待他，不为什么，他是我的第一份工作。工作中有着种种不堪，有着种种痛苦，他在我的记忆里都是值得回忆的，记录着我所努力过的每一天。</p><p>​虽然，我每天都在说，不要碰施工，不要碰土木，会变得不幸，但我不能否认，这个行业带给我的经验，不论是去哪里都能受用的，包括我后面所面试的工作。</p><p>​在钢构公司上班，包括加班的日子，算工作日已经有两年了，我在期间获益良多。</p><p>​不管是<code>OFFICE</code> 亦或是<code>python</code>还有<code>cmd</code>、<code>vba</code>等高效办公软件我都是在工作期间边学边用的，</p><p>另外还有数据清洗能力，表格制作展示能力，也有了自己的方法，此外还有承认错误改正错误的意识，都是在这里培养出来的，<em>毕竟原来的我，是从来都不会觉得我走的方向有问题</em>。</p><p>​在那边上半的日子，难熬又飞快，不知不觉中已经过了两年，我开始变得焦虑。因为我发现我的学习能力在慢慢下降，因为长期失眠，巨大的工作压力，导致记忆力在逐渐变差。直到有一天，我惊恐的发现，我不会九九乘法了！</p><p>​这是何等的可笑！接近二十年的时间，几乎每天都在使用的东西，应该已经深入变成本能了才对，但是我却是十以内的乘法都会计算不出来！</p><p>​那是我开始觉得，我应该寻找新的道路了，再做下去，可能以后就只能被拴在这一眼能看到头的生活里。</p><p>​所以不久以后，我找到了一份在车企的采购工作SQE，供应商质量管理。这是我的第二份工作，我同样热爱他，尽管他只有短短的几天时间。是我高估了我的自我调节、承压能力。再好的弹簧在经受过度的压力，也会变形，失去原有的弹性，我也一样。长期的生活和心理的压力，让我变得自闭且焦躁。</p><p>​于是我停止了一切网络活动，有空的时候都在翻阅林清玄先生的散文集，渴望从中能找出一些心灵的慰藉。</p><p>​我很喜欢的一篇就是先生所写的《过火》，先生年少时因为性格内向且软弱，以至于面对事情都是畏缩、退让。我觉得此时我也如同年少的他一样，面对未知和困难，就会想要逃避，要放弃。不论什么时候，我都没有了面对生活的勇气。先生最后，走过了属于他的那堆火，而我的要过的火又在哪里呢，我的内心是一片荒芜。</p><p>​在狭小的公寓宿舍里，我最喜欢的事情就是舍友不在的时候眺望窗外，外面川流的车辆，往来的行人，他们都有此刻想要去的地方。若是夜间亮起了灯光，在十楼能够看到城市霓虹，在这钢筋水泥构筑成的城市里，灯光与夜色交织，给这座冰冷坚硬的城市披上了柔和的外衣，色彩斑斓，不禁让人沉迷其中，电力可真是人类历史上最伟大的发现！</p><p>​十年霜影转庭梧，此夕羁人独向隅。这千灯万火之中，没有一盏灯是属于我的，我突然好想家了。在外求学、工作近有八年，每次都是聚散匆匆，我发现，好像很久没有和家里人说过话了。我们家没有常联系的习惯，不是什么必须本人出面的事情，可能一年都不会通一次电话，在此影响下，我发现我身边也没有什么朋友，分别以后就算一开始联系几次，后面也逐渐没有声音了。</p><p>​想到这，我觉得张爱玲写的几句话特别合适我。</p><p><em><strong>旧人不知我近况，</strong></em><br><em><strong>新人不知我过往。</strong></em></p><p>​或许是天生我就不适合交际，也懒得于交际。我能够和路边的陌生人涛涛不绝的聊天，也能在各个场面应付的游刃有余，但实际上我对这些事情都并不关注，因为我总是<em>我</em>，以<em>我</em>为核心。我不喜欢把时间用在意外来到的吃饭，喝酒，唱歌这种没有预约的事情上，反而我周围的朋友们都是临时想去的多，渐渐的，很多时候，这些交际活动都不会带上我了，而我也乐得如此。</p><p>​偶尔我会觉得我这样是不是不和人群，也会尝试着去参加周围圈子的交际活动，但往往在这种看似放松的活动回来，我都需要花好长时间来抚平内心的疲惫感。我就是心思单纯，不能承受太多外界的打扰的一个人，渐渐的我就变成乐一个自我封闭的孤独者。</p><p>​回想起在SQE离职前的两天，新同事们邀请我去参加他们的周末聚会。其实明面是他们的聚会，但是我很清楚，这就是为了欢迎新人所举办的。我觉得我的新同事们都是一群特别好的人，工作能力很优秀，年轻很有活力。和我这种年少早衰，暮气沉沉的少年老人不一样（我记得我妈妈总是这样说我，和周围的年轻人不一样，直到现在我才发现确实我像个迟暮老人一般），我在他们身上看到了我所没有的东西，当时我想着是不是我也能像他们一样，对生活保持热爱呢。</p><p>​好无奈的是，回去之后的两天，我还每天对自己说，要融入集体，做个正常的年轻人，但每天在公司，我都是连食堂都不想去吃，更别说和人交流。在几天强迫自己改变以后，终于还是承受不住了。我想是时候回家好好休整一下了。随即几天，我提出了离职，主管经理和人事那边找我谈了几次话，我觉得他们说的很对，后续的事情也验证了他们说的话，但是我当时真的太疲惫了，只想着回到我那个安静的小房间，好好睡上一段时间。</p><p>​回到家里以后，我直接昏天黑地的睡了好几天，终于恢复了点精神。因为当时我是骗家里人说是公司休假回来的，所以不能呆太久，我就收拾了点衣服，随便找了辆大巴车，来了一场不知终点的随即旅途。</p><p>​到了目的地以后，遇到了个热心的小表弟，骑着小电动车带着我和我笨重的背包。本来是想住旅店的，结果在表弟热情的招待下，就去他们家住了几天，期间他们负责买菜，我负责做饭，偶尔骑着小电动车去菜市场逛逛，吃一碗当地特色的酸粉。白天不是很热的时候，我会帮忙整理家门前面的那块菜地，或者去后山那块荒地上挖掉石头，给它种上之前在网上买的花种。也不知道现在花开了没有，我走不久以后，他们一家也外出远门工作了，好久都没联系。</p><p>​那段时间是我过的最充实的一段时间，可是辞职的事情不知道是从哪里泄露了，只能无奈回家认错。临别前一天，刚好是小表弟的生日，我给他去镇上定了一个大蛋糕，做了辣子鸡和红油钵钵鸡。离开的时候，我不舍的看着我开辟出来的花圃，菜地刚种下的豆苗，每天傍晚看日落的躺椅，不远处的青山…….本来过几天再试试自己做糍粑的，我想，可惜没时间了。</p><p>​</p><p>​<strong>人在低谷的时候，最难忍受的不是【痛苦】，而是【孤独】</strong>。</p><p>​在忻城回到家中又过了一个月，我还是没有找到工作，在这乡下，没什么乐子的地方，关于某某的流言是流传的飞快的。特别是我这种外出求学的大学生，本来是一件令父母欣慰，脸上都有光的事情，但现在却在家里啃老，没在外面挣到钱，一下子就成为了附近茶余饭后的谈资。我不敢出门，每天呆在房间里看书，打游戏，招聘软件都翻烂了也不知道要找一份什么样的工作，到底什么工作才适合我。</p><p>​找了很多工作，也去了很多面试，从南到北，旅费花了好几千块钱，但是都没能有一份工作顺利入职的。从一开始的仍对现在的就业状况抱有希望，到后面的绝望，最后到现在彻底躺平，这就是我这段时间来的心路历程。</p><p>​我不知道现在的社会，是不是能对像我这样的内向者有足够的接受和理解，但只能怪自己，吃不了生活的苦，不能接受人多的环境，就算住宿舍也不能接受舍友的生活习惯。我记得去深圳一家机构的时候，安排入住了四人公寓。狭小逼仄的环境里面住了三个男人，里面充满了烟味、汗味、脚臭味。垃圾随地的散落在周围。外面的盥洗室已经到处都是灰色的水垢、黄色的菌斑，卫生间到处都是废弃的瓶子和塑料，更让人恶心的是，地板全是黄色的污垢。</p><p>​住进去的第一个晚上，我买了各种清洁工具，忍着恶心把所有的地方勉强收拾干净，本来以为就这样慢慢收拾也能住。没想到晚上的时间才是更难熬的。由于上一份工作的专业经历，我很快就知道了这个公寓是用预制板拼接出来的，外部只是用强度板做了覆盖，没有填充隔音，上下水管都是做在室内的一条大管，也没包隔音棉。所以每当有人在活动，周围的房间能听到一清二楚，有人使用使用水都能听见上下水的声音。还有就是，我的几位舍友都打呼噜，声音非常奇怪，还有一位喜欢磨牙，另外一位睡醒喜欢抽烟，一个晚上抽了五根。</p><p>​我在睡在上铺，又不敢动作太大，架床摇摇晃晃的，我怕稍微用点力就塌下去了。就这样，我被折磨了一个晚上，一点也没睡着。旅途上因为晕车，所以我也很少能好睡眠，出门前都会很担忧，也睡不着，相当于我已经三天都没怎么睡觉了。半夜了肚子好饿，才想起来，已经二十多个小时没吃过东西了，路上我从不吃东西，因为怕吐出来。</p><p>​果然我还是吃不了生活的苦，一夜无眠之后，我勉强打起精神去到办公楼看看工作环境，到了那边也没人搭理我，我就在一个办公室等了半个小时，后面才有人带我去一个小会议室。半个小时的观察，我觉得我还是不该来的，我们在网上聊的时候是说做一份统计打单、分析报告的工作，在这边又变成了电销了，虽然是让学生买课，但是还是销售。我不讨厌销售，但百分之八十是电话陌拜，还有充满诱导的谎言，是我的价值观不能接受的。</p><p>​所以我再次失业了，并且是彻底的失业。一直到今天，我仍没有找到一份合适的工作。外部的压力，内部精神无休止的内耗，我发现我已经彻底躺平了。拿着仅有几千块钱，每天吃饭睡觉刷抖音，连书也不堪了。我体会到了这种堕落，摆烂的罪恶感所带来的快感，我会心安理得：啊~就这样吧，反正也不会有什么好结果。</p><p>​就这样我变成了一个社会废人，除了吃饭就是睡觉，偶尔出门去给我的菜地浇浇水。这样日复一日，近些日子，我发现我的精神越来越差了，每天需要睡十多个小时，并且还经常处于犯困，但是没有社保，我也不敢去医院检查，这就是躺平摆烂的后果吧。</p><p>​我想着，是不是因为每天躺太久的原因，就把我的个人博客重新拿出来更新一下了，规律一下生活，转移些注意力是不是精神状态能回复过来。</p><p>​最坏的打算，就算真的有什么不好的事情发生，我也能在这段时间记录一些我的生活吧。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;关于失联很久以后…&quot;&gt;&lt;a href=&quot;#关于失联很久以后…&quot; class=&quot;headerlink&quot; title=&quot;关于失联很久以后…&quot;&gt;&lt;/a&gt;关于失联很久以后…&lt;/h4&gt;&lt;p&gt;​		很长一段时间都没更新HEXO的博客了，电脑被雷击穿主板以后，因为没布局服务器，</summary>
      
    
    
    
    <category term="随想录" scheme="http://huangxiaoruipo.github.io/categories/%E9%9A%8F%E6%83%B3%E5%BD%95/"/>
    
    
    <category term="每日随笔" scheme="http://huangxiaoruipo.github.io/tags/%E6%AF%8F%E6%97%A5%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://huangxiaoruipo.github.io/2022/11/04/hello-world/"/>
    <id>http://huangxiaoruipo.github.io/2022/11/04/hello-world/</id>
    <published>2022-11-04T15:00:35.803Z</published>
    <updated>2022-11-05T06:44:43.648Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>正则表达式（其一）</title>
    <link href="http://huangxiaoruipo.github.io/2022/05/07/zheng-ze-biao-da-shi/"/>
    <id>http://huangxiaoruipo.github.io/2022/05/07/zheng-ze-biao-da-shi/</id>
    <published>2022-05-07T07:19:15.000Z</published>
    <updated>2022-11-05T06:44:43.651Z</updated>
    
    <content type="html"><![CDATA[<h3 id="python的正则表达式"><a href="#python的正则表达式" class="headerlink" title="python的正则表达式"></a>python的正则表达式</h3><p>python的re模块提供perl风格的的正则表达式，这里简单写一下正则表达的处理函数。</p><h3 id="re-match"><a href="#re-match" class="headerlink" title="re.match"></a>re.match</h3><pre class="line-numbers language-none"><code class="language-none">re.match(pattern, string, flags&#x3D;0)#pattern:匹配表达式#string：匹配字符串flags：控制表达式的匹配方式<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>re.match匹配成功会返回一个匹配对象，否则返回None</p><pre class="line-numbers language-none"><code class="language-none">import reexp1 &#x3D; re.match(&#39;www&#39;, &#39;https:&#x2F;&#x2F;www.bilibili.com&#x2F;video&#x2F;BV1es41127PE?p&#x3D;14&#39;)#起始位置匹配exp2 &#x3D; re.match(&#39;www&#39;, &#39;www.bilibili.com&#x2F;video&#x2F;BV1es41127PE?p&#x3D;14&#39;).span()#非起始位置匹配exp3 &#x3D; re.match(&#39;p&#x3D;14&#39;, &#39;www.bilibili.com&#x2F;video&#x2F;BV1es41127PE?p&#x3D;14&#39;)print(exp2)print(exp3)-------------(0, 3)None<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们可以使用 group(num) 或 groups() 匹配对象函数来获取匹配表达式</p><p> group(num)匹配的整个表达式的字符串，group() 可以一次输入多个组号，在这种情况下它将返回一个包含那些组所对应值的元组。</p><p> groups()  返回一个包含所有小组字符串的元组，从 1 到 所含的小组号</p><pre class="line-numbers language-none"><code class="language-none">import reline &#x3D; &#39;Cats are smarter than dogs&#39;matchObject &#x3D; re.match(r&#39;(.*) are (.*?) .*&#39;, line, re.M | re.I)#r表示忽略反斜杠，不视作转移符号#(.*)是第一个分组，匹配换行符之外所有的字符串，后面接的是&#96; are &#96;表示第一组匹配到&#96; are &#96;之前结束#&#96; are &#96;后面是第二个(.*?)分组，表示从&#96; are &#96;后面开始匹配，?是非贪婪模式，匹配最短字符#第三个.*是表示后面的所有字符，不在分组内if matchObject:    print(f&#39;matchObject.group():&#123;matchObject.group()&#125;&#39;)    #group()等于group(0)，表示匹配到的完整文本    print(f&#39;matchObject.group(1):&#123;matchObject.group(1)&#125;&#39;)    #group(1)，表示匹配到的第一个组    print(f&#39;matchObject.group(2):&#123;matchObject.group(2)&#125;&#39;)    #group(2)，表示匹配到的第二个组    print(f&#39;matchObject.groups():&#123;matchObject.groups()&#125;&#39;)    #groups()，表示匹配到的所有组    #没有group(3)，因为最后一个&#96;.*&#96;不是组else:    print(&#39;no match&#39;)----------------------matchObject.group():Cats are smarter than dogsmatchObject.group(1):CatsmatchObject.group(2):smartermatchObject.groups():(&#39;Cats&#39;, &#39;smarter&#39;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="re-match和re-search区别"><a href="#re-match和re-search区别" class="headerlink" title="re.match和re.search区别"></a>re.match和re.search区别</h3><pre class="line-numbers language-none"><code class="language-none">import reline &#x3D; &#39;Cats are smarter than dogs&#39;matchObject &#x3D; re.match(r&#39;(.*) are (.*?) .*&#39;, line, re.M | re.I)searchObject &#x3D; re.search(r&#39;(.*) are (.*?) .*&#39;, line, re.M | re.I)matchObject_mod &#x3D; re.match(r&#39;dogs&#39;, line, re.M | re.I)searchObject_mod &#x3D; re.search(r&#39;dogs&#39;, line, re.M | re.I)if matchObject:    print(f&#39;matchObject.group(）:&#123;matchObject.group()&#125;&#39;)    print(f&#39;matchObject.group(1）:&#123;matchObject.group(1)&#125;&#39;)    print(f&#39;matchObject.group(2）:&#123;matchObject.group(2)&#125;&#39;)    print(f&#39;matchObject.groups(）:&#123;matchObject.groups()&#125;&#39;)else:    print(&#39;no match&#39;)if searchObject:    print(f&#39;searchObject.group(）:&#123;searchObject.group()&#125;&#39;)    print(f&#39;searchObject.group(1）:&#123;searchObject.group(1)&#125;&#39;)    print(f&#39;searchObject.group(2）:&#123;searchObject.group(2)&#125;&#39;)    print(f&#39;searchObject.groups(）:&#123;searchObject.groups()&#125;&#39;)else:    print(&#39;no match&#39;)if matchObject_mod:    print(f&#39;matchObject_mod:&#123;matchObject_mod&#125;&#39;)    print(f&#39;matchObject_mod:&#123;matchObject_mod.group()&#125;&#39;)else:    print(&#39;no match&#39;)if searchObject_mod:    print(f&#39;searchObject_mod:&#123;searchObject_mod&#125;&#39;)    print(f&#39;searchObject_mod:&#123;searchObject_mod.group()&#125;&#39;)else:    print(&#39;no match&#39;)-------------------------matchObject.group(）:Cats are smarter than dogsmatchObject.group(1）:CatsmatchObject.group(2）:smartermatchObject.groups(）:(&#39;Cats&#39;, &#39;smarter&#39;)searchObject.group(）:Cats are smarter than dogssearchObject.group(1）:CatssearchObject.group(2）:smartersearchObject.groups(）:(&#39;Cats&#39;, &#39;smarter&#39;)no matchsearchObject_mod:&lt;re.Match object; span&#x3D;(22, 26), match&#x3D;&#39;dogs&#39;&gt;searchObject_mod:dogs<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以发现，re.match和re.search区别在于查询的条件不一样，re.match正则匹配到的字符串开始的内容不符，则会匹配失败，返回None；re.search区别则会匹配整个字符串，返回第一个匹配到的字符位置。</p><h3 id="检索和替换"><a href="#检索和替换" class="headerlink" title="检索和替换"></a>检索和替换</h3><pre class="line-numbers language-none"><code class="language-none">re.sub(pattern, repl, string, count&#x3D;0, flags&#x3D;0)#pattern : 正则中的模式字符串。#repl : 替换的字符串，也可为一个函数。#string : 要被查找替换的原始字符串。#count : 模式匹配后替换的最大次数，默认 0 表示替换所有的匹配。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>实例</p><pre class="line-numbers language-none"><code class="language-none">date &#x3D; &#39;2020-05-07    # 这是今天的日期&#39;# 删除后面的注释this_date &#x3D; re.sub(r&#39;\s*#.*$&#39;,&quot;&quot;,date)#匹配任意空格到 # 字符，#字符后面任意字符直至字符串末尾（$表示匹配字符串末尾）this_num &#x3D; re.sub(r&#39;\D&#39;,&quot;&quot;,date)#匹配所有非数字字符（\D表示所有非数字字符）print(this_date)print(this_num)---------------2020-05-0720200507<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>repl参数是一个函数</p><p>我们可以将匹配的字符串内容都用函数处理</p><p>实例：将匹配到的数字乘以2</p><pre class="line-numbers language-none"><code class="language-none">def double(matched):    value &#x3D; int(matched.group(&#39;value&#39;))    return str(value * 2)s &#x3D; &#39;A23G4HFD567&#39;print(re.sub(&#39;(?P&lt;value&gt;\d+)&#39;, double, s))#?P&lt;value&gt;的意思是命名一个为value的组，\d+是匹配条件，整个?P&lt;value&gt;\d+的意思是命名一个为value的组，匹配规则符合\d+-------------------A46G8HFD1134<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/2022/05/07/zheng-ze-biao-da-shi/image-20220507182017074.png" alt="匹配结果"></p><p>可以看到第一次匹配到的数字23被传递到 double函数里面，用group（）方法将23取出转为整型后返回2倍的23，和输出结果一致。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;python的正则表达式&quot;&gt;&lt;a href=&quot;#python的正则表达式&quot; class=&quot;headerlink&quot; title=&quot;python的正则表达式&quot;&gt;&lt;/a&gt;python的正则表达式&lt;/h3&gt;&lt;p&gt;python的re模块提供perl风格的的正则表达式，这里简</summary>
      
    
    
    
    <category term="Python" scheme="http://huangxiaoruipo.github.io/categories/Python/"/>
    
    
    <category term="正则表达" scheme="http://huangxiaoruipo.github.io/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE/"/>
    
  </entry>
  
  <entry>
    <title>遍历文件夹、匹配文件、打开切片修改文件案例</title>
    <link href="http://huangxiaoruipo.github.io/2022/05/03/bian-li-wen-jian-jia-pi-pei-wen-jian-da-kai-qie-pian-xiu-gai-wen-jian-an-li/"/>
    <id>http://huangxiaoruipo.github.io/2022/05/03/bian-li-wen-jian-jia-pi-pei-wen-jian-da-kai-qie-pian-xiu-gai-wen-jian-an-li/</id>
    <published>2022-05-03T14:10:41.000Z</published>
    <updated>2022-11-05T06:44:43.654Z</updated>
    
    <content type="html"><![CDATA[<pre class="line-numbers language-none"><code class="language-none">import osimport re# 遍历文件夹下的指定后缀文件def get_file_list(base_dir&#x3D;&#39;.&#39;, target_ext&#x3D;&#39;&#39;) -&gt; list:    fname_list &#x3D; []    for fname in os.listdir(base_dir):        # 遍历指定目录        path &#x3D; os.path.join(base_dir, fname)        # 把文件名和所在目录名连接起来        if os.path.isfile(path):            # 判断是否是“文件”类型            fname_main, fname_ext &#x3D; os.path.splitext(fname)            # 把文件名和后缀切分开            if fname_ext &#x3D;&#x3D; target_ext or target_ext &#x3D;&#x3D; &#39;&#39;:                # 判断是否指定的后缀名                fname_list.append(path)                # 将符合条件的文件全路径名加入列表        # elif os.path.isdir(path):        # # 判断是否文件夹类型        #     temp_list &#x3D; get_file_list(path, target_ext)        # # 递归调用查找子目录        #     fname_list &#x3D; fname_list + temp_list        # # 将递归调用返回的文件名列表合并        # else:        #     pass    return fname_list  # 返回查到的文件名列表def replace_file(fname_list, replce_list&#x3D;&#39;.&#39;, save_dir&#x3D;&#39;.&#39;):    with open(replce_list) as f1:        # 打开一个包含班组制作信息的文件        for each_line in f1:            # 做分割处理            (part, part_ban, quanty) &#x3D; each_line.strip(&#39;\n&#39;).split(&#39;+&#39;, 2)            for file in fname_list:                # 遍历文件下所有的文件                with open(file) as f2:                    NC_vaul &#x3D; f2.readlines()                    # 判断文件名称是否和清单一致                if part &#x3D;&#x3D; NC_vaul[1][:len(NC_vaul[1]) - 1]:                    # 替换列表内容                    NC_vaul[1] &#x3D; part_ban + &#39;\n&#39;                    NC_vaul[7] &#x3D; quanty + &#39;\n&#39;                    # 将readliness内容储存到文本文件                    with open(save_dir + part_ban[3:], &quot;w&quot;) as f3:                        f3.writelines(NC_vaul)if __name__ &#x3D;&#x3D; &quot;__main__&quot;:    file_list &#x3D; get_file_list(r&#39;.&#x2F;txt&#x2F;&#39;, &#39;.nc1&#39;)    replace_file(file_list, replce_list&#x3D;&#39;.&#x2F;txt&#x2F;班组—制作数量.txt&#39;, save_dir&#x3D;&#39;.&#x2F;txt&#x2F;&#39;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>两年前刚到公司上班的时候写的脚本，因为公司管理模式没细化的原因，粗放的给每个加工零件。结果有一天外协出去的图纸因为零件数量问题要我去一个一个修改，几千图纸一个一个打开修改（痛苦面具），每出一次图纸我都要去BIM里面修改一次零件数据也太麻烦了，百度了数控文件的类型是德标的（大概），然后对比了几组不同的图纸，发现了每组零件名称和数量所在的位置。</p><p>通过人工添加制作加工清单，然后将本批次需要加工的所有数控遍历，匹配名称后，用readliness读取出来（readline读取单行，反正我修改不了），readliness返回的是一个列表，我们可以通过切片的方式去修改固定位置的数据。</p><p>最后新建一个文件将它保存起来，不在原地保存。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;pre class=&quot;line-numbers language-none&quot;&gt;&lt;code class=&quot;language-none&quot;&gt;import os
import re


# 遍历文件夹下的指定后缀文件
def get_file_list(base_dir&amp;#x3D;&amp;#</summary>
      
    
    
    
    <category term="Python" scheme="http://huangxiaoruipo.github.io/categories/Python/"/>
    
    
    <category term="OS模块" scheme="http://huangxiaoruipo.github.io/tags/OS%E6%A8%A1%E5%9D%97/"/>
    
    <category term="遍历文件" scheme="http://huangxiaoruipo.github.io/tags/%E9%81%8D%E5%8E%86%E6%96%87%E4%BB%B6/"/>
    
    <category term="指定后缀" scheme="http://huangxiaoruipo.github.io/tags/%E6%8C%87%E5%AE%9A%E5%90%8E%E7%BC%80/"/>
    
    <category term="持久化储存数据" scheme="http://huangxiaoruipo.github.io/tags/%E6%8C%81%E4%B9%85%E5%8C%96%E5%82%A8%E5%AD%98%E6%95%B0%E6%8D%AE/"/>
    
    <category term="列表切片" scheme="http://huangxiaoruipo.github.io/tags/%E5%88%97%E8%A1%A8%E5%88%87%E7%89%87/"/>
    
  </entry>
  
  <entry>
    <title>Python pandas note</title>
    <link href="http://huangxiaoruipo.github.io/2022/04/30/python-pandas-note/"/>
    <id>http://huangxiaoruipo.github.io/2022/04/30/python-pandas-note/</id>
    <published>2022-04-30T08:36:31.000Z</published>
    <updated>2022-11-05T06:44:43.642Z</updated>
    
    <content type="html"><![CDATA[<h3 id="pandas基本功能"><a href="#pandas基本功能" class="headerlink" title="pandas基本功能"></a>pandas基本功能</h3><p>使用的是tekla13.0版本套料工具生成工程时，形成的<code>report</code>数据，名字是<code>myflie.csv</code></p><h4 id="读取数据"><a href="#读取数据" class="headerlink" title="读取数据"></a>读取数据</h4><p>pandas采用read_csv方法读取文件时会出现编码错误，在代码首部加上说明，读取时使用<code>gbk</code>的编码方式，全部代码如下：</p><pre class="line-numbers language-none"><code class="language-none"># -- coding : utf-8 --# coding: utf-8import pandas as pdimport openpyxlimport numpy as npimport timeimport xlrddata &#x3D; pd.read_csv(&#39;myfile.csv&#39;, header&#x3D;None, sep&#x3D;&#39;,&#39;, encoding&#x3D;&#39;gbk&#39;)print(data)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/2022/04/30/python-pandas-note/image-20220501093337810.png" alt="读取结果"></p><p>可以看到一共在<code>myfile.csv</code>内读取到了7行13列的数据，第一行是标题行，第三列到第十列被压缩起来了，我们无法看到数据的全貌，提供方法去展示数据：</p><p>在print之前添加一个<code>pd.set_option(&#39;display.max_columns&#39;, None)</code>的属性，顺便的把<code>header</code>设置为0，把第一行做为列索引（<code>index_col=0</code>可以设置列索引，<code>usecols=[1,2,3]</code>用来选定对应的列数）。</p><pre class="line-numbers language-none"><code class="language-none">import pandas as pdimport openpyxlimport numpy as npimport timeimport xlrddata &#x3D; pd.read_csv(&#39;myfile.csv&#39;, header&#x3D;0, sep&#x3D;&#39;,&#39;, encoding&#x3D;&#39;gbk&#39;)pd.set_option(&#39;display.max_columns&#39;, None)print(data)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/2022/04/30/python-pandas-note/image-20220501100819754.png" alt="全部数据"></p><h4 id="空值处理"><a href="#空值处理" class="headerlink" title="空值处理"></a>空值处理</h4><p>在查看所有的数据以后，我们发现原始的数据的第二列（在<code>Dataframe</code>中是索引<code>loc[0]</code>），这时候我们对数据行进行一些处理，把<code>NaN</code>行先去掉，就可以在读取的时候直接跳过这行，<code>Drawing No</code>也是一个空数据，在后续的处理中去掉。两种种方法去处理NaN值：</p><p><em><strong>读取的时候直接跳过</strong></em></p><pre class="line-numbers language-none"><code class="language-none">import pandas as pddata &#x3D; pd.read_csv(&#39;myfile.csv&#39;, header&#x3D;0, sep&#x3D;&#39;,&#39;, skiprows&#x3D;[1], usecols&#x3D;[0, 1, 2, 3, 5, 6, 7, 8, 9, 10, 11],                   encoding&#x3D;&#39;gbk&#39;)pd.set_option(&#39;display.max_columns&#39;, None)  # 显示全部列pd.set_option(&#39;display.unicode.ambiguous_as_wide&#39;, True)  # 列名称数据对齐pd.set_option(&#39;display.unicode.east_asian_width&#39;, True)  # 列名称数据对齐print(data.head())  # 打印前5行<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/2022/04/30/python-pandas-note/image-20220501111255451.png" alt="直接在读取的时候去掉空值"></p><p><em><strong>读取完毕再处理</strong></em></p><p>我们很多时候数据缺失并不是整行或者整列的，我们读取之后再来处理</p><pre class="line-numbers language-none"><code class="language-none">import pandas as pdimport openpyxlimport numpy as npimport timeimport xlrddata &#x3D; pd.read_csv(&#39;myfile.csv&#39;, header&#x3D;0, sep&#x3D;&#39;,&#39;,                   encoding&#x3D;&#39;gbk&#39;)pd.set_option(&#39;display.max_columns&#39;, None)  # 显示全部列pd.set_option(&#39;display.unicode.ambiguous_as_wide&#39;, True)  # 列名称数据对齐pd.set_option(&#39;display.unicode.east_asian_width&#39;, True)  # 列名称数据对齐# print(data.head())  # 打印前5行print(data.columns)  # 查看列名columns &#x3D; data.columns  # 赋值给columnsprint(type(columns))  # 查看类型&lt;class &#39;pandas.core.indexes.base.Index&#39;&gt;data.replace(&#39;$NULL$&#39;, np.nan, inplace&#x3D;True)  # 替换字符串为nan<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none"># 对于列的缺失，我们提供两个思路处理# for col in columns:#     # print(data[col].count())#     if data[col].count() &#x3D;&#x3D; 0:  # 判断是否全空#         data.drop(labels&#x3D;col, axis&#x3D;1, inplace&#x3D;True)-----------------------------第二种col &#x3D; data.count() &#x3D;&#x3D; 0print(col) #返回的是每列的布尔值len &#x3D; len(col)print(len)for i in range(len):    if col[i]:        data.drop(labels&#x3D;col.index[i],axis&#x3D;1,inplace&#x3D;True)print(data)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/2022/04/30/python-pandas-note/image-20220501121112252.png" alt="将Drawing No这个无效列去除"></p><p>我们再用<code>data.isnull().sum()</code>去对数据表空值进行统计，方便后续处理</p><p><img src="/2022/04/30/python-pandas-note/image-20220501121328869.png" alt="统计空值"></p><p>用<code>dropna</code>方法去除空行，指定 <code>how=&#39;all&#39;</code></p><pre class="line-numbers language-none"><code class="language-none">data1 &#x3D; data.dropna(axis&#x3D;0, how&#x3D;&#39;all&#39;, thresh&#x3D;None, subset&#x3D;None, inplace&#x3D;False)#只有全部为空才回被删除print(data1)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>参数说明：</strong></p><ul><li>axis：默认为 0，表示逢空值剔除整行，如果设置参数 axis＝1 表示逢空值去掉整列。</li><li>how：默认为 ‘any’ 如果一行（或一列）里任何一个数据有出现 NA 就去掉整行，如果设置 how&#x3D;’all’ 一行（或列）都是 NA 才去掉这整行。</li><li>thresh：设置需要多少非空值的数据才可以保留下来的。</li><li>subset：设置想要检查的列。如果是多个列，可以使用列名的 list 作为参数。</li><li>inplace：如果设置 True，将计算得到的值直接覆盖之前的值并返回 None，修改的是源数据。</li></ul><p><img src="/2022/04/30/python-pandas-note/image-20220501122356900.png" alt="去除全部是空的行"></p><p>假如这样行列处理完毕以后，我们数据还是有某些个值缺失，数据量大的时候可以这么做</p><pre class="line-numbers language-none"><code class="language-none">data_isnull &#x3D; data[data.isnull().values &#x3D;&#x3D; True] #查找所有空值<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/2022/04/30/python-pandas-note/image-20220502084330664.png" alt="缺失数据"></p><p>很轻松就找到了整个表有缺失的值</p><p>另外补充查看各个列缺失情况的方法如下</p><pre class="line-numbers language-none"><code class="language-none">data.isnull().sum() #8、对缺失值进行统计，统计出每一个字段有多少缺失值。# 光看缺失值数量 却不对比总样本数是不对的。data.isnull().mean() # 可以查看各列缺失值的比例data.drop(columns&#x3D;&#39;xx&#39;,inplace&#x3D;True) #删除缺失值大于某个比例的列data&#x3D;data.loc[:,df.isnull().mean()&lt;0.5] #剔除缺失值比例大于50%的列data.dropna() #删除所有缺失值所在的行和列，像炸弹一样横纵两列都消失其他的:data.fillna() # 填充缺失值。data[&#39;age&#39;].fillna(data[&#39;age&#39;].mean())  # 用均值填充data[&#39;age&#39;].fillna(method&#x3D;&#39;bfill&#39;)  # 用此空后面的值填充data[&#39;age&#39;].fillna(method&#x3D;&#39;ffill&#39;)  # 用此空前面的值填充，有顺序的序列可以此二法填充<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>查找na所在的行和列</p><pre class="line-numbers language-none"><code class="language-none">position &#x3D; data.isnull().stack()[lambda x:x].index.tolist()print(position) #[(5, &#39;Part Name&#39;)]-----------小例子-----------#!&#x2F;usr&#x2F;bin&#x2F;evn python# -*-coding:utf8 -*-import pandas as pddata &#x3D; [[None, None, 90, 80],[57, 43, 89, 65],[78, 50, 67, 78],[None, 78, 90, 73],[67, 45, 78, 76],[77, 88, None, 45],[52, 110, 120, 99],[131, 13, 32, 12]]index &#x3D; [&#39;语文&#39;, &#39;英语&#39;, &#39;数学&#39;, &#39;政治&#39;, &#39;物理&#39;, &#39;化学&#39;, &#39;生物&#39;, &#39;地理&#39;]column &#x3D; [&#39;张三&#39;, &#39;李四&#39;, &#39;王五&#39;, &#39;周六&#39;]data &#x3D; pd.DataFrame(data,index&#x3D;index,columns&#x3D;column)print(data)print(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&quot;)for columname in data.columns:    if data[columname].count() !&#x3D; len(data):         loc &#x3D; data[columname][data[columname].isnull().values&#x3D;&#x3D;True].index.tolist()         print(&#39;列名：&quot;&#123;&#125;&quot;, 第&#123;&#125;行位置有缺失值&#39;.format(columname,loc))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h4><pre class="line-numbers language-none"><code class="language-none"># 索引# 直接使用索引行列print(data[&#39;Part Name&#39;][5])# 使用locprint(data.loc[5,&#39;Part Name&#39;])print(data.loc[data[&#39;Part Name&#39;].isnull()])   #等价于print(data[data[&#39;Part Name&#39;].isnull()])print(&#39;-&#39; * 20)print(data[data[&#39;Part Name&#39;].isnull()])# 使用iloc,返回的是个dataframeprint(data.iloc[4:5,1:2])*****************nannan   S&#x2F;N Part Name Material Grade  Thickness    Mark No  Weight  Surface Area  \5  5.0       NaN          Q355B       18.0  a-2P-1239   141.3         2.185                      Ref. No  Qty Nesting Task  Nested Qty  5  （B105-0042）施工总承包  2.0     myfile02         0.0  --------------------   S&#x2F;N Part Name Material Grade  Thickness    Mark No  Weight  Surface Area  \5  5.0       NaN          Q355B       18.0  a-2P-1239   141.3         2.185                      Ref. No  Qty Nesting Task  Nested Qty  5  （B105-0042）施工总承包  2.0     myfile02         0.0    Part Name5       NaN<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="修改单元格的值"><a href="#修改单元格的值" class="headerlink" title="修改单元格的值"></a>修改单元格的值</h4><pre class="line-numbers language-none"><code class="language-none">data.loc[5,&#39;Part Name&#39;] &#x3D; data.loc[5,&#39;Mark No&#39;]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/2022/04/30/python-pandas-note/image-20220502112841786.png" alt="修改单元格的值"></p><h5 id="基本运算"><a href="#基本运算" class="headerlink" title="基本运算"></a>基本运算</h5><h6 id="行间运算"><a href="#行间运算" class="headerlink" title="行间运算"></a>行间运算</h6><p>在实例表中行间加法无意义，简单示例</p><p>加法</p><p><code>data[columns1]+ data[columns2]</code>列之间相加<strong>columns</strong>是索引</p><p>对于行间所有数据求和，除了上述方法一个一个加外还可以</p><p><code>data.eval(&#39;合计=columns1+columns2+columns3&#39;)</code></p><p>或者</p><p><code>data.sum(axis=1)</code>指定轴是列</p><p>将求和数据储存到<code>dataframe</code>中</p><p><code>data[合计] = data.sum(axis=1)</code></p><p>四则运算同理，减法，乘法，除法不再一一列出。</p><h6 id="比较运算"><a href="#比较运算" class="headerlink" title="比较运算"></a>比较运算</h6><p><code>data[columns1]&gt;&lt;data[columns2]</code>返回的是一组布尔值</p><p>也可以通过<code>query()</code>函数查看结果</p><p><code>data.query([columns1&gt;[columns2])</code></p><p>同等于<code>data[data[columns1]&gt;&lt;data[columns2]]</code></p><p><code>data.query([columns1==&#39;A&#39;)</code></p><p>同等于<code>data[data[columns1]==[A]]</code></p><p><strong>这两个方法都可以查看到比较运算的表结果</strong></p><h6 id="汇总运算"><a href="#汇总运算" class="headerlink" title="汇总运算"></a>汇总运算</h6><p>即对行之间的运算函数</p><p>count() 计数函数，会统计数据中非空个数</p><p><code>data.count()</code></p><p>类似len()和shape但是更加详细</p><p>省缺参数默认纵向统计，指定<code>data.count(axis=1)</code>可以横向统计列之间的空值</p><p>sum()</p><p>前面也展示了sum()的用法</p><p>默认省缺参数是对纵向求和，data.sum(axis&#x3D;1)是对横向求和</p><p>mean()</p><p>平均数函数，类似sum()</p><p>可以指定内部参与运算的列和行，例如</p><p><code>data.mean(columns1，columns1)</code></p><p>除以上计算外，Pandas还支持最大值max()，最小值min()，另外进阶函数有：中位数函数median()、求众数函数mode()、方差函数var()、标准差函数std()、分位数函数quantile()和相关性函数corr()。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>花了三天时间把之前的笔记整理出来，很多有意思的东西也重新复习了一下，类似高阶数组的广播，高阶数组的轴向表示方法都重新复习了一遍。</p><p>接下来就是将PIL和matplotlib整理出来，先贴上一代码防止找不到</p><pre class="line-numbers language-none"><code class="language-none">#图像手绘模拟from PIL import Imageimport numpy as npa &#x3D; np.array(Image.open(r&quot;C:\Users\LENOVO\Desktop\21c55b005c746518e5e9f3522d9416b5.jpg&quot;).convert(&#39;L&#39;)).astype(&#39;float&#39;)depth &#x3D; 10grad &#x3D; np.gradient(a)   #获取图像灰度梯度grad_x,grad_y &#x3D; grad    #获取横纵梯度值grad_x&#x3D;grad_x*depth&#x2F;100.    #横向归一整理grad_y&#x3D;grad_y*depth&#x2F;100.    #纵向归一整理A &#x3D; np.sqrt(grad_x**2+grad_y**2+1.)uni_x &#x3D; grad_x&#x2F;Auni_y &#x3D; grad_y&#x2F;Auni_z &#x3D; 1.&#x2F;A    #得到归一单位法向量值vec_el &#x3D; np.pi&#x2F;2.2  #建立光源三维坐标体系，对应横纵弧长vec_az &#x3D; np.pi&#x2F;4.dx &#x3D; np.cos(vec_el)*np.cos(vec_az)  #获取光源具体位置，计算影响因子dy &#x3D; np.cos(vec_el)*np.sin(vec_az)dz &#x3D; np.sin(vec_el)b &#x3D; 225*(dx*uni_x+dy*uni_y+dz*uni_z)    #归一求出具体的光源影响量b&#x3D;b.clip(0,225)     #避免数据溢出im &#x3D; Image.fromarray(b.astype(&#39;uint8&#39;))     #用framarry将得到的灰度转换为对应数组im.save(r&quot;C:\Users\LENOVO\Desktop\手绘.jpg&quot;)      #保存图形<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">#import  matplotlib.pyplot as plt    #重新定义matplotlib的函数为pltimport numpy as np&quot;&quot;&quot;plt.subplot2grid((3,3),(0,0),colspan&#x3D;3)plt.plot([0,2,4,6,8],[3,1,4,5,2])   #建立一个x坐标是02468Y，y坐标是31452的元素 绘制折线图plt.ylabel(&#39;纵坐标&#39;,fontproperties&#x3D;&#39;SimHei&#39;,fontsize&#x3D;25,color&#x3D;&#39;green&#39;)     #y轴标签为Gradeplt.xlabel(&#39;横坐标&#39;,fontproperties&#x3D;&#39;SimHei&#39;,fontsize&#x3D;25,color&#x3D;&#39;green&#39;)plt.title(&#39;示例&#39;,fontproperties&#x3D;&#39;SimHei&#39;,fontsize&#x3D;25)plt.annotate(&#39;this is anne&#39;,xy&#x3D;(6,4.5),xytext&#x3D;(4,2),arrowprops&#x3D;dict(facecolor&#x3D;&#39;black&#39;,shrink&#x3D;0.1,width&#x3D;1)) plt.axis([-1,10,0,6])   #x轴从-1到10，Y轴从0到6，另外subplot可以分割绘图区域plt.subplot2grid((3,3),(1,0),colspan&#x3D;2) #分割绘图区域labels &#x3D; &#39;Frogs&#39;,&#39;Hogs&#39;,&#39;Dogs&#39;,&#39;Logs&#39;   #柱状图sizes &#x3D; [15,30,45,10]explode &#x3D; (0,0.1,0,0)plt.pie(sizes,explode&#x3D;explode,labels&#x3D;labels,autopct&#x3D;&#39;%1.1f%%&#39;,shadow&#x3D;False,startangle&#x3D;90)plt.axis(&#39;equal&#39;)plt.subplot2grid((3,3),(1,2),rowspan&#x3D;2)np.random.seed(0)mu,sigma &#x3D; 100,20   #均值和标准差a &#x3D; np.random.normal(mu,sigma,size&#x3D;100)plt.hist(a,40,density&#x3D;1,histtype&#x3D;&#39;stepfilled&#39;,facecolor&#x3D;&#39;blue&#39;,alpha&#x3D;0.75)plt.title(&#39;Histogram&#39;)plt.subplot2grid((3,3),(2,0))&quot;&quot;&quot;N&#x3D;20    #饼图theta&#x3D;np.linspace(0.0,2*np.pi,N,endpoint&#x3D;False)radii &#x3D; 10*np.random.rand(N)width&#x3D;np.pi&#x2F;4*np.random.rand(N)ax &#x3D; plt.subplot(111,projection&#x3D;&#39;polar&#39;)bars &#x3D; ax.bar(theta,radii,width&#x3D;width,bottom&#x3D;0.0)for r,bar in zip(radii,bars):    bar.set_facecolor(plt.cm.viridis(r&#x2F;10.))    bar.set_alpha(0.5)#plt.subplot2grid((3,3),(2,1))plt.grid(True)plt.show()  #输出图形<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;pandas基本功能&quot;&gt;&lt;a href=&quot;#pandas基本功能&quot; class=&quot;headerlink&quot; title=&quot;pandas基本功能&quot;&gt;&lt;/a&gt;pandas基本功能&lt;/h3&gt;&lt;p&gt;使用的是tekla13.0版本套料工具生成工程时，形成的&lt;code&gt;repo</summary>
      
    
    
    
    <category term="Python" scheme="http://huangxiaoruipo.github.io/categories/Python/"/>
    
    
    <category term="Python" scheme="http://huangxiaoruipo.github.io/tags/Python/"/>
    
    <category term="pandas" scheme="http://huangxiaoruipo.github.io/tags/pandas/"/>
    
  </entry>
  
  <entry>
    <title>accordion特效</title>
    <link href="http://huangxiaoruipo.github.io/2022/04/30/accordion-te-xiao/"/>
    <id>http://huangxiaoruipo.github.io/2022/04/30/accordion-te-xiao/</id>
    <published>2022-04-30T03:55:30.000Z</published>
    <updated>2022-11-05T06:44:43.646Z</updated>
    
    <content type="html"><![CDATA[<h3 id="收集到了一个很好看的手风琴特效"><a href="#收集到了一个很好看的手风琴特效" class="headerlink" title="收集到了一个很好看的手风琴特效"></a>收集到了一个很好看的手风琴特效</h3><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="800" height="360" src="/myapp/accordion/"></iframe><h3 id="CSS源码"><a href="#CSS源码" class="headerlink" title="CSS源码"></a>CSS源码</h3><pre class="line-numbers language-none"><code class="language-none">&lt;style&gt;    *&#123;        margin: 0;        padding: 0;        box-sizing: border-box;    &#125;    body&#123;        height: 100vh;        display: flex;        justify-content: center;        align-items: center;        background-color: #eef1f5;    &#125;    .loading&#123;        display: flex;        flex-direction: row;    &#125;    .loading div&#123;        position: relative;        width: 40px;        height: 200px;        background: linear-gradient(to bottom,rbga(0,0,0,0.05));        margin: 20px;        border-radius: 20px;        border: 2px solid #eef1f5;        box-shadow: 15px 15px 20px rgba(0, 0, 0, 0.1),        -15px -15px 20px #fff,        inset -5px -5px 5px rgba(255, 255, 255, 0.5),        inset 5px 5px 5px rgba(0, 0, 0, 0.5);        overflow: hidden;    &#125;    .loading div::before&#123;        content: &quot;&quot;;        position: absolute;        top: 0;        left: 0;        width: 36px;        height: 36px;        border-radius: 50%;        box-shadow: inset -5px -5px 5px rgba(0, 0, 0,0.1),        0 420px 0 400px lightblue;        animation: animate 2s ease-in-out infinite;        animation-delay: calc(var(--x)*0.3s);        transform: translateY(160px);    &#125;    @keyframes animate &#123;                0%&#123;            transform: translateY(160px);            filter: hue-rotate(0deg);                    &#125;        50%&#123;            transform: translateY(0px);            filter: hue-rotate(180deg);        &#125;        100%&#123;            transform: translateY(160px);            filter: hue-rotate(360deg);        &#125;    &#125;&lt;&#x2F;style&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h3><pre class="line-numbers language-none"><code class="language-none">&lt;body&gt;    &lt;div class&#x3D;&quot;loading&quot;&gt;        &lt;div style&#x3D;&quot;--x:0&quot;&gt;&lt;&#x2F;div&gt;        &lt;div style&#x3D;&quot;--x:1&quot;&gt;&lt;&#x2F;div&gt;        &lt;div style&#x3D;&quot;--x:2&quot;&gt;&lt;&#x2F;div&gt;        &lt;div style&#x3D;&quot;--x:3&quot;&gt;&lt;&#x2F;div&gt;        &lt;div style&#x3D;&quot;--x:4&quot;&gt;&lt;&#x2F;div&gt;        &lt;div style&#x3D;&quot;--x:5&quot;&gt;&lt;&#x2F;div&gt;      &lt;&#x2F;div&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;收集到了一个很好看的手风琴特效&quot;&gt;&lt;a href=&quot;#收集到了一个很好看的手风琴特效&quot; class=&quot;headerlink&quot; title=&quot;收集到了一个很好看的手风琴特效&quot;&gt;&lt;/a&gt;收集到了一个很好看的手风琴特效&lt;/h3&gt;&lt;iframe frameborder=&quot;</summary>
      
    
    
    
    <category term="CSS" scheme="http://huangxiaoruipo.github.io/categories/CSS/"/>
    
    
    <category term="HTML" scheme="http://huangxiaoruipo.github.io/tags/HTML/"/>
    
    <category term="CSS" scheme="http://huangxiaoruipo.github.io/tags/CSS/"/>
    
    <category term="CSS3" scheme="http://huangxiaoruipo.github.io/tags/CSS3/"/>
    
  </entry>
  
  <entry>
    <title>Python numpy基础（一）</title>
    <link href="http://huangxiaoruipo.github.io/2022/04/28/python-numpy-ji-chu-yi/"/>
    <id>http://huangxiaoruipo.github.io/2022/04/28/python-numpy-ji-chu-yi/</id>
    <published>2022-04-28T10:01:43.000Z</published>
    <updated>2022-11-05T06:44:43.640Z</updated>
    
    <content type="html"><![CDATA[<h3 id="NumPy是什么"><a href="#NumPy是什么" class="headerlink" title="NumPy是什么"></a>NumPy是什么</h3><p>NumPy（numerical python）是python数据计算最重要的基础包。</p><p>可以说多数的科学计算、数据分析的模块都是用NumPy的数组最为基础构建的。</p><h3 id="为什么选择NumPy"><a href="#为什么选择NumPy" class="headerlink" title="为什么选择NumPy"></a>为什么选择NumPy</h3><ul><li>使用连续内存块储存数据，独立其他的Python内置对象。基于C语言编写的算法库可以直接操作内存，不必进行类型检查或者其他的前期工作。（抄来的，理解不了）</li><li>NumPy数组使用的内存更少，直接对数组进行复杂的计算，不需要使用for循环。</li></ul><pre class="line-numbers language-none"><code class="language-none">list1 &#x3D; [1,2,5,8]list2 &#x3D; [1,1,5,1000]print(list1 &gt; list2) &#x2F;&#x2F;Trueprint(list2 &gt; list1) &#x2F;&#x2F;False# 挨个比较元素，如果首次比较到的元素大&#x2F;小，则按照顺序输出True&#x2F;False<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="NumPy的强大"><a href="#NumPy的强大" class="headerlink" title="NumPy的强大"></a>NumPy的强大</h3><p>NumPy可以使用for循环或者其他循环体去直接对数组进行加减乘除的运算和比较，减少代码的使用量和节省内存、运行时间等。</p><h3 id="NumPy的使用方法"><a href="#NumPy的使用方法" class="headerlink" title="NumPy的使用方法"></a>NumPy的使用方法</h3><h4 id="直接创建array列表"><a href="#直接创建array列表" class="headerlink" title="直接创建array列表"></a>直接创建array列表</h4><pre class="line-numbers language-none"><code class="language-none">import numpy as nplist1 &#x3D; [1, 4, 5, 7, 9, 20]arr1 &#x3D; np.array(list1)list2 &#x3D; list(&#39;abcde&#39;)  # [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;]arr2 &#x3D; np.array(list2)print(arr1)  # [ 1  4  5  7  9 20]print(arr2)  # [&#39;a&#39; &#39;b&#39; &#39;c&#39; &#39;d&#39; &#39;e&#39;]# 计算arr1arr3 &#x3D; (arr1 + 1) ** 2print(arr3)  # [  4  25  36  64 100 441]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以发现numpy使用array()可以很简单就将List类型转化为numpy数组，进而可以很快的对每个元素进行运算，不需要再去<code>for i in list：</code>去遍历数组，计算每个数据的平方和<code>（i = i**2）</code>,再去<code>res = append[i]</code>，这样写简直不要太麻烦！！！</p><h4 id="用np-arange-beg-end-step-创建数组"><a href="#用np-arange-beg-end-step-创建数组" class="headerlink" title="用np.arange(beg,end,step)创建数组"></a>用np.arange(beg,end,step)创建数组</h4><pre class="line-numbers language-none"><code class="language-none">import numpy as np# 创建0-4的一个数组arr4 &#x3D; np.arange(5)print(arr4)  # [0 1 2 3 4]# 创建一个10-14的数组arr5 &#x3D; np.arange(10, 15)print(arr5)  # [10 11 12 13 14]# 创建一个10-20，步长为2的等差数列数组arr6 &#x3D; np.arange(10, 20, 2)print(arr6)  # [10 12 14 16 18]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此外我们可以使用shape元素去查看数组的形状，reshape修改数组的形状。</p><pre class="line-numbers language-none"><code class="language-none">import numpy as nplist1 &#x3D; np.arange(12).reshape(3, 4)  # 创建一个0-11,且为3行4列的数组list2 &#x3D; np.arange(10, 22).reshape(3, 4)  # 创建一个10-21，且为4行4列的数组list3 &#x3D; list2 - list1print(list1)# [[ 0  1  2  3]#  [ 4  5  6  7]#  [ 8  9 10 11]]print(list2)# [[10 11 12 13]#  [14 15 16 17]#  [18 19 20 21]]print(list3)# [[10 10 10 10]#  [10 10 10 10]#  [10 10 10 10]]print(list1.shape)  # (3, 4)print(np.arange(10, 20).shape)  # (10,)arr1 &#x3D; np.arange(24).reshape(3,2,4) # 这是一个三维数组，# numpy对数组的约定是这样的，第一个维度指的是数组有几层（3层）# 第二个维度指的是数组每层有多数行（2行）# 第三个维度指的是每行有多少个元素（4个）# 简记为3层，后面2个表示2行4列的线性数列print(arr1)# [[[ 0  1  2  3]#   [ 4  5  6  7]]##  [[ 8  9 10 11]#   [12 13 14 15]]##  [[16 17 18 19]#   [20 21 22 23]]]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果shape返回的是(10,)则说明它是一个一维数组，(3, 4)二维数组，更多的(3,2,4)</p><h4 id="zeros，zeros-like-ones，ones-like-empyty，empyty-like"><a href="#zeros，zeros-like-ones，ones-like-empyty，empyty-like" class="headerlink" title="zeros，zeros_like,ones，ones_like,empyty，empyty_like"></a>zeros，zeros_like,ones，ones_like,empyty，empyty_like</h4><p>见名知意，zero指的是创建值全是0的数组</p><p>zeros_like创建一个和指定数组形状一样的，值是0的数组</p><p>同理是ones，ones_like,empyty，empyty_like</p><p>ones元素全部为1，empyty全部变为空值，占位符是1.</p><pre class="line-numbers language-none"><code class="language-none">import numpy as nparr1 &#x3D; np.arange(12)arr2 &#x3D; arr1.reshape(3,4)arr3 &#x3D; np.ones(12)arr4 &#x3D; np.ones((3,3))arr5 &#x3D; np.ones_like(arr2)print(arr1)print(arr2)print(arr3)print(arr4)print(arr5)arr1# [ 0  1  2  3  4  5  6  7  8  9 10 11]arr2# [[ 0  1  2  3]#  [ 4  5  6  7]#  [ 8  9 10 11]]arr3# [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]arr4# [[1. 1. 1.]#  [1. 1. 1.]#  [1. 1. 1.]]arr5# [[1 1 1 1]#  [1 1 1 1]#  [1 1 1 1]]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="eye创建对角矩阵数组"><a href="#eye创建对角矩阵数组" class="headerlink" title="eye创建对角矩阵数组"></a>eye创建对角矩阵数组</h4><pre class="line-numbers language-none"><code class="language-none">import numpy as nparr1 &#x3D; np.eye(5)print(arr1)# [[1. 0. 0. 0. 0.]#  [0. 1. 0. 0. 0.]#  [0. 0. 1. 0. 0.]#  [0. 0. 0. 1. 0.]#  [0. 0. 0. 0. 1.]]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="full创建满数组"><a href="#full创建满数组" class="headerlink" title="full创建满数组"></a>full创建满数组</h4><pre class="line-numbers language-none"><code class="language-none">import numpy as nparr2 &#x3D; np.full((3,4),123)print(arr2# [[123 123 123 123]#  [123 123 123 123]#  [123 123 123 123]]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="numpy数组的数据类型"><a href="#numpy数组的数据类型" class="headerlink" title="numpy数组的数据类型"></a>numpy数组的数据类型</h3><p>python的list列表，其中可以储存所有的数据类型，但是并不是所有的类型都是储存在list中，耳数把对象的索引储存在list，当垃圾回收机制检测的时候，需要一个个区域遍历，占用资源大，numpy开辟了一整块内存，相当于只有一个对象来粗存这值，所以只需要把索引打包成一个对象，这个对象里面只能去储存一种数据类型。</p><p><img src="/2022/04/28/python-numpy-ji-chu-yi/image-20220428205422893.png" alt="dttype的类型"></p><pre class="line-numbers language-none"><code class="language-none">import numpy as nplist1 &#x3D; [0,1.1,2.2,3.3,4.4,5.5,6.6]# 创建数组的时候选择一个数据类型arr1 &#x3D; np.array(list1,dtype&#x3D;np.int16)print(arr1)print(arr1.dtype)arr2 &#x3D; arr1.astype(np.float32)print(arr2)print(arr2.dtype)# [0 1 2 3 4 5 6]# int16# [0. 1. 2. 3. 4. 5. 6.]# float32<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 可以发现，我们能将numpy数组的dtype类型在创建的时候定义，也可以在我们创建好后重新转换我们的数据类型。</p><p><strong>注意</strong></p><ol><li><em>当float转换为int的时候，会自动删除小数点之后的数据，只保留整数位</em></li><li><em>数字转换成字符串也是可以的</em></li></ol><h3 id="numpy数组的索引类型"><a href="#numpy数组的索引类型" class="headerlink" title="numpy数组的索引类型"></a>numpy数组的索引类型</h3><h4 id="普通索引和数据切片"><a href="#普通索引和数据切片" class="headerlink" title="普通索引和数据切片"></a>普通索引和数据切片</h4><pre class="line-numbers language-none"><code class="language-none">import numpy as nplist1 &#x3D; np.arange(12).reshape(3,4)print(list1)print(list1[1,1])print(list1[1:,1:])  # 输出第二行之后，并且第二列之后# [[ 0  1  2  3]#  [ 4  5  6  7]#  [ 8  9 10 11]]# 5# [[ 5  6  7]#  [ 9 10 11]]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="花式索引"><a href="#花式索引" class="headerlink" title="花式索引"></a>花式索引</h4><pre class="line-numbers language-none"><code class="language-none">import numpy as nplist1 &#x3D; np.arange(24).reshape(6, 4)print(list1)print(&#39;-&#39; * 20)print(list1[[1, 4, 3]])# [[ 0  1  2  3]#  [ 4  5  6  7]#  [ 8  9 10 11]#  [12 13 14 15]#  [16 17 18 19]#  [20 21 22 23]]# --------------------# [[ 4  5  6  7]#  [16 17 18 19]#  [12 13 14 15]]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>若是需要确切值可以这么写</p><pre class="line-numbers language-none"><code class="language-none">import numpy as nplist1 &#x3D; np.arange(24).reshape(6, 4)print(list1)print(&#39;-&#39; * 20)print(list1[[1, 4, 3]])print(&#39;-&#39; * 20)print(list1[[1, 4, 3],[2,3,0]])# [[ 0  1  2  3]#  [ 4  5  6  7]#  [ 8  9 10 11]#  [12 13 14 15]#  [16 17 18 19]#  [20 21 22 23]]# --------------------# [[ 4  5  6  7]#  [16 17 18 19]#  [12 13 14 15]]# --------------------# [ 6 19 12]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="布尔索引"><a href="#布尔索引" class="headerlink" title="布尔索引"></a>布尔索引</h4><pre class="line-numbers language-none"><code class="language-none">import numpy as nplist1 &#x3D; np.arange(24).reshape(6, 4)index &#x3D; [True,False,True,False,True,False]print(list1)print(&#39;-&#39; * 20)print(list1[index])# [[ 0  1  2  3]#  [ 4  5  6  7]#  [ 8  9 10 11]#  [12 13 14 15]#  [16 17 18 19]#  [20 21 22 23]]# --------------------# [[ 0  1  2  3]#  [ 8  9 10 11]#  [16 17 18 19]]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="numpy自带的数组函数"><a href="#numpy自带的数组函数" class="headerlink" title="numpy自带的数组函数"></a>numpy自带的数组函数</h3><h4 id="通用函数：快速的元素级数组函数"><a href="#通用函数：快速的元素级数组函数" class="headerlink" title="通用函数：快速的元素级数组函数"></a>通用函数：快速的元素级数组函数</h4><p>常用一元ufunc：</p><p><img src="/2022/04/28/python-numpy-ji-chu-yi/image-20220428212328292.png" alt="常用一元ufunc"></p><p>常用二元ufunc：</p><p><img src="/2022/04/28/python-numpy-ji-chu-yi/image-20220428212503504.png" alt="常用一元ufunc："></p><p>补充一下</p><pre class="line-numbers language-none"><code class="language-none"># where(表达式，f1,f2),类似于三目运算符# 表达式为True返回f1，表达式为False返回f2# arr2: [[19  3 19 -1 -2]#  [ 8  5  3 19  5]#  [-8 16 -1  6  4]#  [ 0 17 -3 18  3]]arr2 &#x3D; np.where(arr2 &#x3D;&#x3D; 0,1,arr2) #  意思是arr2里面的元素是0时，返回该元素是1，不是0就返回该元素本身print(arr2)# 输出# [[19  3 19 -1 -2]#  [ 8  5  3 19  5]#  [-8 16 -1  6  4]#  [ 1 17 -3 18  3]]————————————————<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;NumPy是什么&quot;&gt;&lt;a href=&quot;#NumPy是什么&quot; class=&quot;headerlink&quot; title=&quot;NumPy是什么&quot;&gt;&lt;/a&gt;NumPy是什么&lt;/h3&gt;&lt;p&gt;NumPy（numerical python）是python数据计算最重要的基础包。&lt;/p&gt;</summary>
      
    
    
    
    <category term="Python" scheme="http://huangxiaoruipo.github.io/categories/Python/"/>
    
    
    <category term="Python" scheme="http://huangxiaoruipo.github.io/tags/Python/"/>
    
    <category term="NumPy" scheme="http://huangxiaoruipo.github.io/tags/NumPy/"/>
    
  </entry>
  
  <entry>
    <title>Excel数据表函数基本操作</title>
    <link href="http://huangxiaoruipo.github.io/2022/04/25/excel-shu-ju-biao-han-shu-ji-ben-cao-zuo/"/>
    <id>http://huangxiaoruipo.github.io/2022/04/25/excel-shu-ju-biao-han-shu-ji-ben-cao-zuo/</id>
    <published>2022-04-25T02:35:40.000Z</published>
    <updated>2022-11-05T06:44:43.636Z</updated>
    
    <content type="html"><![CDATA[<h3 id="VLOOKUP-函数"><a href="#VLOOKUP-函数" class="headerlink" title="VLOOKUP 函数"></a>VLOOKUP 函数</h3><h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><p><code>=VLOOKUP (要查找的项、要查找位置、区域中包含要返回的值的列号、返回近似匹配或精确匹配 - 指示为 1/TRUE 或 0/FALSE) 。</code></p><p><code>=VLOOKUP (lookup_value, table_array, col_index_num, [range_lookup]) </code></p><h4 id="VLOOKUP-引用Excel官方的例子"><a href="#VLOOKUP-引用Excel官方的例子" class="headerlink" title="VLOOKUP 引用Excel官方的例子"></a>VLOOKUP 引用Excel官方的例子</h4><p><img src="/2022/04/25/excel-shu-ju-biao-han-shu-ji-ben-cao-zuo/image-20220425105128317.png" alt="图例"></p><p>我们可以使用VLOOKUP函数<code>=VLOOKUP（105,A2:E7,5,FALSE）</code>表示去查找ID是105，在表内A2:E7的RANGE，返回的值是第5列的单元格内容，然后用一个YEARFRAC(开始时间，结束时间,时间格式)去返回一个时间间距<code>=YEARFRAC(DATE(2014,6,30),DATE(55,3,4),1)</code>，结果是59.3，用INT转为整数结果是图示的59。</p><h3 id="XLOOKUP-函数"><a href="#XLOOKUP-函数" class="headerlink" title="XLOOKUP 函数"></a>XLOOKUP 函数</h3><p>关于<code>VLOOKUP</code> ，在2021新版本以后官方支持了一个新的函数<code>XLOOKUP</code>，使用 <code>XLOOKUP</code> 函数按行查找表格或区域内容</p><h4 id="基本用法-1"><a href="#基本用法-1" class="headerlink" title="基本用法"></a>基本用法</h4><p><code>=XLOOKUP(lookup_value, lookup_array, return_array, [if_not_found], [match_mode], [search_mode])</code></p><table><thead><tr><th align="left">参数</th><th>说明</th></tr></thead><tbody><tr><td align="left"><strong>lookup_value</strong>             必需</td><td>要搜索的值   <em>如果省略，XLOOKUP 将返回它在 lookup_array*<em>中查找的空白lookup_array。</em></em></td></tr><tr><td align="left"><strong>lookup_array</strong>             必需</td><td>要搜索的数组或区域</td></tr><tr><td align="left"><strong>return_array</strong>              必需</td><td>要返回的数组或区域</td></tr><tr><td align="left"><strong>[if_not_found]</strong>             可选</td><td>如果找不到有效的匹配项，则返回你if_not_found [if_not_found] 文本。如果找不到有效的匹配项，并且缺少 [if_not_found]，<strong>则#N&#x2F;A。</strong></td></tr><tr><td align="left"><strong>[match_mode]</strong>             可选</td><td>指定匹配类型：0 - 完全匹配。 如果未找到，则返回 #N&#x2F;A。 这是默认选项。-1 - 完全匹配。 如果没有找到，则返回下一个较小的项。1 - 完全匹配。 如果没有找到，则返回下一个较大的项。2 - 通配符匹配，其中 *, ? 和 ~ 有<a href="https://support.office.com/zh-cn/f1/topic/%E5%9C%A8%E6%90%9C%E7%B4%A2%E4%B8%AD%E4%BD%BF%E7%94%A8%E9%80%9A%E9%85%8D%E7%AC%A6-ef94362e-9999-4350-ad74-4d2371110adb?NS=EXCEL&Version=19">特殊含义</a>。</td></tr><tr><td align="left"><strong>[search_mode]</strong>             可选</td><td>指定要使用的搜索模式：1 - 从第一项开始执行搜索。 这是默认选项。-1 - 从最后一项开始执行反向搜索。2 - 执行依赖于 lookup_array 按<em>升序</em>排序的二进制搜索。 如果未排序，将返回无效结果。2 - 执行依赖于 lookup_array 按<em>降序</em>排序的二进制搜索。 如果未排序，将返回无效结果。</td></tr></tbody></table><h4 id="非常好用"><a href="#非常好用" class="headerlink" title="非常好用"></a>非常好用</h4><h5 id="单条件查询，类似VLOOKUP"><a href="#单条件查询，类似VLOOKUP" class="headerlink" title="单条件查询，类似VLOOKUP"></a>单条件查询，类似VLOOKUP</h5><p><code>=XLOOKUP($A$16:$A$19,$A$2:$A$10,D2:D10,&quot;无&quot;)</code>这个查询方式针对单个数据对应，它可以使用数组，查找到对应数据，且默认使用精确匹配。</p><p><img src="/2022/04/25/excel-shu-ju-biao-han-shu-ji-ben-cao-zuo/image-20220425144918552.png" alt="单条件查询"></p><h5 id="模糊查询，指定通配符模式"><a href="#模糊查询，指定通配符模式" class="headerlink" title="模糊查询，指定通配符模式"></a>模糊查询，指定通配符模式</h5><p><code>=XLOOKUP(&quot;*&quot;&amp;D16&amp;&quot;*&quot;,$A$2:$A$10,$B$2:$B$10,&quot;没找到&quot;,2)</code> <code>XLOOKUP</code>默认不支持通配符匹配，只有将第五个参数选项设置为通配符模式<strong>2</strong></p><p>才支持通配符。</p><p><img src="/2022/04/25/excel-shu-ju-biao-han-shu-ji-ben-cao-zuo/image-20220425145930885.png" alt="通配符匹配模式"></p><p><img src="/2022/04/25/excel-shu-ju-biao-han-shu-ji-ben-cao-zuo/image-20220425150015610.png"></p><h5 id="区间查询，比LOOKUP好用多了"><a href="#区间查询，比LOOKUP好用多了" class="headerlink" title="区间查询，比LOOKUP好用多了"></a>区间查询，比LOOKUP好用多了</h5><p>原来的LOOKUP函数还要我们对表格进行有序排序，那可真的不方便，一旦打乱顺序，查找的数据不对了，用上XLOOKIP以后再也不用担心这个问题。</p><p><code>=XLOOKUP(E2,$F$15:$F$19,$G$15:$G$19,&quot;&quot;,1)</code>，第五个参数+1表示匹配最大值，-1表示匹配最小值。</p><p><img src="/2022/04/25/excel-shu-ju-biao-han-shu-ji-ben-cao-zuo/image-20220425150940139.png" alt="区间匹配"></p><h5 id="查询最后一条结果"><a href="#查询最后一条结果" class="headerlink" title="查询最后一条结果"></a>查询最后一条结果</h5><p>李四和王五两位同志在在最后几日发奋图强，提高了自己的评分，我们查询数据的时候按日期升序排列，</p><p><img src="/2022/04/25/excel-shu-ju-biao-han-shu-ji-ben-cao-zuo/image-20220425151855778.png" alt="查询最后数据条目"></p><h5 id="横向查询"><a href="#横向查询" class="headerlink" title="横向查询"></a>横向查询</h5><p>对于横向查询，直接单列使用的话可以类似纵向查询，直接输入查找值，匹配值和返回值就行了。但是对于多列，顺序要是打乱或者稍微格式不一致，就会出现查找错误的情况，这时候我们可以使用两个XLOOKUP来套嵌使用。</p><p><code>=XLOOKUP($A17,$A$2:$A$12,XLOOKUP(B$16,$A$1:$H$1,$A$2:$H$12))</code>内嵌的XLOOKUP函数负责返回一个正确单列，外侧的XLOOKUP函数负责去查询匹配需要的目标数据。</p><p><img src="/2022/04/25/excel-shu-ju-biao-han-shu-ji-ben-cao-zuo/image-20220425154458130.png" alt="横向交叉查询"></p><h5 id="多条件查询"><a href="#多条件查询" class="headerlink" title="多条件查询"></a>多条件查询</h5><p>XLOOKUP直接支持数组，不用像VLOOKUP函数一样需要使用数组公式转换</p><p><code>=XLOOKUP($A17&amp;$B17,XLOOKUP($A$16,$A$1:$H$1,$A$2:$H$12)&amp;XLOOKUP($B$16,$A$1:$H$1,$A$2:$H$12),XLOOKUP(C$16,$A$1:$H$1,$A$2:$H$12))</code></p><p>这次来点稍微复杂的，多条件+交叉表查询，用XLOOKUP去分别返：回查询数组（日期&amp;姓名），返回数组（销售额），通过限定行列的引用方式，就能直接粘贴到其他单元格使用。</p><p><img src="/2022/04/25/excel-shu-ju-biao-han-shu-ji-ben-cao-zuo/image-20220425160601879.png" alt="多条件查询套嵌"></p><p><img src="/2022/04/25/excel-shu-ju-biao-han-shu-ji-ben-cao-zuo/image-20220425160219114.png" alt="多条件查询"></p><h5 id="区域查询"><a href="#区域查询" class="headerlink" title="区域查询"></a>区域查询</h5><p><code>=SUM(XLOOKUP($B$17,$H$2:$H$12,G2:G12):XLOOKUP($B$18,H2:H12,G2:G12))</code>值得注意，这个返回的是有序的日期期间，其实就是返回了两个日期中间的数组，如果要求某个日期区间的单元格值，配合SUMIFS使用。</p><p><img src="/2022/04/25/excel-shu-ju-biao-han-shu-ji-ben-cao-zuo/image-20220425162253393.png" alt="区域查询求和"></p><h5 id="动态表查询"><a href="#动态表查询" class="headerlink" title="动态表查询"></a>动态表查询</h5><p>假设有结构一致的多张数据表，名称分别为2019 2020 2021 2022</p><p>2020（其余表不列出）</p><table><thead><tr><th>板块</th><th>销售额</th></tr></thead><tbody><tr><td>饮料</td><td>5000</td></tr><tr><td>食品</td><td>2200</td></tr><tr><td>日用</td><td>1000</td></tr></tbody></table><p>我们需要查询每年的不同板块的销售额可以通过INDIRECT引用单元格去构建<code>年</code>和<code>2020</code>的单元格分别是A1  ， B1</p><table><thead><tr><th>年</th><th>2020</th></tr></thead><tbody><tr><td>板块</td><td>销售额</td></tr><tr><td>饮料</td><td></td></tr><tr><td>食品</td><td></td></tr><tr><td>日用</td><td></td></tr><tr><td></td><td></td></tr></tbody></table><p>在单元格内输入<code>=XLOOKUP(A4,INDIRECT($B$1&quot;!A:A&quot;),INDIRECT($B$1&quot;!B:B&quot;))</code>可以查询到相关板块的数据，意思就是查询A4目标值，它的查询数组在表2020的A:A，返回值在2020的B:B。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>基本上这两个函数已经涵盖了我们所有需要用到的东西，XLOOKUP能代替INDEX+MATCH的工作内容，使用INDEX+MATCH套嵌的方法也能很好去制作出非常不错的动态查询效果。下面给出一个求满足某些条件求和的例子：</p><p><code>=SUMIFS(INDEX(数据查询表，0，MATCH(要查询的值标题,查询的表头源，查询方式))***``###上面这句就是通过查询标题所在的位置，通过INDEX去返回整个求和列，和XLOOKUP达到的效果是一样的###``***,INDEX(数据查询表,0,MATCH(要查询的值,表头源,查询方式))***``###上面这段的意思就是返回一个条件列###``***,查询条件)</code></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;VLOOKUP-函数&quot;&gt;&lt;a href=&quot;#VLOOKUP-函数&quot; class=&quot;headerlink&quot; title=&quot;VLOOKUP 函数&quot;&gt;&lt;/a&gt;VLOOKUP 函数&lt;/h3&gt;&lt;h4 id=&quot;基本用法&quot;&gt;&lt;a href=&quot;#基本用法&quot; class=&quot;head</summary>
      
    
    
    
    <category term="Excel" scheme="http://huangxiaoruipo.github.io/categories/Excel/"/>
    
    
    <category term="VLOOKUP" scheme="http://huangxiaoruipo.github.io/tags/VLOOKUP/"/>
    
    <category term="XLOOKUP" scheme="http://huangxiaoruipo.github.io/tags/XLOOKUP/"/>
    
    <category term="INDEX" scheme="http://huangxiaoruipo.github.io/tags/INDEX/"/>
    
    <category term="MATCH" scheme="http://huangxiaoruipo.github.io/tags/MATCH/"/>
    
    <category term="SUMIFS" scheme="http://huangxiaoruipo.github.io/tags/SUMIFS/"/>
    
  </entry>
  
  <entry>
    <title>Python快排实现原理及代码</title>
    <link href="http://huangxiaoruipo.github.io/2022/04/24/python-kuai-pai-shi-xian-yuan-li-ji-dai-ma/"/>
    <id>http://huangxiaoruipo.github.io/2022/04/24/python-kuai-pai-shi-xian-yuan-li-ji-dai-ma/</id>
    <published>2022-04-24T00:41:02.000Z</published>
    <updated>2022-11-05T06:44:43.643Z</updated>
    
    <content type="html"><![CDATA[<h3 id="快排原理"><a href="#快排原理" class="headerlink" title="快排原理"></a>快排原理</h3><p>在一串数组中选择任意一个数字为基准，将数组的数据和基准数据相比较，比基准大的数据在基准数字的右边，比基准小的数据在基准的左边，此时基准元素位于正确的位置，它无需参与排序，接着对拆分的数组进行递归，再次进行快速排序，直到序列中的所有记录均为有序序列。</p><p>快速排序用到了<strong>分而治之</strong>的思想，把大的拆成小的，小的拆成更小的。</p><h3 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h3><p>设定当前待排序序列为<code>alist[start:end]</code>，其中<code>start &lt;= end</code>，只有待排数据足够小的时候才会进行直接排序，否则按三步骤处理：</p><ol><li>分解<br>在<code>alist[start:end]</code>选定一个基准序列<code>mid = alist[start]</code>(注：这个基准可以是第一个元素、最后一个元素、中间元素等等，这里取第一个)。以此为标准，我们定义两个指针对<code>low = start</code> <code>high= end</code>,将待排序列遍历比较大小，划分为<code>alist[start]</code>– <code>mid</code>与<code>mid</code>–<code>alist[end]</code>序列，<code>mid</code>不参与排序，并使前者全部的元素值小于<code>mid</code>，后者的全部元素值大于等于<code>mid</code>。</li><li>递归<br>对于子序列，我们分别调用递归函数<code>quick_sort(alist, start, low - 1)</code>基准左边， <code>quick_sort(alist, low + 1, end)</code>基准右边，对其进行快速排序，退出条件自然是<code>start &gt;= end</code>，因为之前排序的时候，结束时<code>low</code>、<code>high</code>重合，我们可以将基准元素放到该位置，<code>alist[low] = mid</code>（<code>alist[high] = mid</code>也可以）。</li><li>合并<br>由于排序都是原地进行的，递归结束后，所有的元素都已经排序完毕。</li></ol><h3 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h3><pre class="line-numbers language-none"><code class="language-none">def quick_sort(alist, start, end):    &quot;&quot;&quot;快速排序&quot;&quot;&quot;    if start &gt;&#x3D; end:  # 递归的退出条件        return    mid &#x3D; alist[start]  # 设定起始的基准元素    low &#x3D; start  # low为序列左边在开始位置的由左向右移动的游标    high &#x3D; end  # high为序列右边末尾位置的由右向左移动的游标    while low &lt; high:        # 如果low与high未重合，high(右边)指向的元素大于等于基准元素，则high向左移动        while low &lt; high and alist[high] &gt;&#x3D; mid:            high -&#x3D; 1        alist[low] &#x3D; alist[high]  # 走到此位置时high指向一个比基准元素小的元素,将high指向的元素放到low的位置上,此时high指向的位置空着,接下来移动low找到符合条件的元素放在此处        # 如果low与high未重合，low指向的元素比基准元素小，则low向右移动        while low &lt; high and alist[low] &lt; mid:            low +&#x3D; 1        alist[high] &#x3D; alist[low]  # 此时low指向一个比基准元素大的元素,将low指向的元素放到high空着的位置上,此时low指向的位置空着,之后进行下一次循环,将high找到符合条件的元素填到此处    # 退出循环后，low与high重合，此时所指位置为基准元素的正确位置,左边的元素都比基准元素小,右边的元素都比基准元素大    alist[low] &#x3D; mid  # 将基准元素放到该位置,    # 对基准元素左边的子序列进行快速排序    quick_sort(alist, start, low - 1)  # start :0  low -1 原基准元素靠左边一位    # 对基准元素右边的子序列进行快速排序    quick_sort(alist, low + 1, end)  # low+1 : 原基准元素靠右一位  end: 最后if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    alist &#x3D; [54, 26, 93, 17, 77, 31, 44, 55, 20]    quick_sort(alist, 0, len(alist) - 1)    print(alist) # [17, 20, 26, 31, 44, 54, 55, 77, 93]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;快排原理&quot;&gt;&lt;a href=&quot;#快排原理&quot; class=&quot;headerlink&quot; title=&quot;快排原理&quot;&gt;&lt;/a&gt;快排原理&lt;/h3&gt;&lt;p&gt;在一串数组中选择任意一个数字为基准，将数组的数据和基准数据相比较，比基准大的数据在基准数字的右边，比基准小的数据在基准的左边</summary>
      
    
    
    
    <category term="Python" scheme="http://huangxiaoruipo.github.io/categories/Python/"/>
    
    
    <category term="Python" scheme="http://huangxiaoruipo.github.io/tags/Python/"/>
    
    <category term="quicksort" scheme="http://huangxiaoruipo.github.io/tags/quicksort/"/>
    
  </entry>
  
  <entry>
    <title>Python连接MySQL并执行操作</title>
    <link href="http://huangxiaoruipo.github.io/2022/04/21/python-lian-jie-mysql-bing-zhi-xing-cao-zuo/"/>
    <id>http://huangxiaoruipo.github.io/2022/04/21/python-lian-jie-mysql-bing-zhi-xing-cao-zuo/</id>
    <published>2022-04-21T11:00:10.000Z</published>
    <updated>2022-11-05T06:44:43.645Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是MySQLdb"><a href="#什么是MySQLdb" class="headerlink" title="什么是MySQLdb?"></a>什么是MySQLdb?</h3><p>MySQLdb 是用于Python链接Mysql数据库的接口，它实现了 Python 数据库 API 规范 V2.0，基于 MySQL C API 上建立的。</p><h3 id="创建SQL数据库"><a href="#创建SQL数据库" class="headerlink" title="创建SQL数据库"></a>创建SQL数据库</h3><p>在连接数据库之前确认自己已经做了以下事项：</p><ul><li>已经创建了数据库mytest</li><li>在mytest数据库中您已经创建了表 myapp_users</li><li>mytest表字段为 name, age, phone, addtime</li><li>连接数据库mytest使用的用户名为 “root” ，密码为 “123456”,你可以可以自己设定或者直接使用root用户名及其密码，Mysql数据库用户授权请使用Grant命令</li><li>在你的机子上已经安装了 Python MySQLdb 模块</li><li>熟悉SQL基本语句</li></ul><h3 id="连接SQLdb"><a href="#连接SQLdb" class="headerlink" title="连接SQLdb"></a>连接SQLdb</h3><pre class="line-numbers language-none"><code class="language-none">import MySQLdbconnect &#x3D; None  # 连接对象cursor &#x3D; None  # 游标对象try:    # 连接对象    connect &#x3D; MySQLdb.connect(host&#x3D;&#39;localhost&#39;,  # 主机地址                              user&#x3D;&#39;root&#39;,  # 账号                              password&#x3D;&#39;123456&#39;,  # 密码                              database&#x3D;&#39;mytest&#39;,  # 数据库名                              use_unicode&#x3D;True,                              charset&#x3D;&#39;utf8&#39;)  # 指定字符集    # 游标对象    cursor &#x3D; connect.cursor()  # 通过连接对象调用游标cursor()except Exception as e:    print(e)    connect.close()try:    if cursor:            result &#x3D; cursor.execute(&quot;SQL执行语句&quot;)  # 插入操作        connect.commit()  # 提交except Exception as e:    print(e)    connect.rollback()  # 回滚finally:    if cursor:        cursor.close()    if connect:        connect.close()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="创建一个数据表"><a href="#创建一个数据表" class="headerlink" title="创建一个数据表"></a>创建一个数据表</h3><p>如果数据库连接存在我们可以使用execute()方法来为数据库创建表，如下所示创建表myapp_users：</p><pre class="line-numbers language-none"><code class="language-none">import MySQLdbconnect &#x3D; None  # 连接对象cursor &#x3D; None  # 游标对象try:    # 连接对象    connect &#x3D; MySQLdb.connect(host&#x3D;&#39;localhost&#39;,  # 主机地址                              user&#x3D;&#39;root&#39;,  # 账号                              password&#x3D;&#39;123456&#39;,  # 密码                              database&#x3D;&#39;mytest&#39;,  # 数据库名                              use_unicode&#x3D;True,                              charset&#x3D;&#39;utf8&#39;)  # 指定字符集    # 游标对象    cursor &#x3D; connect.cursor()  # 通过连接对象调用游标cursor()except Exception as e:    print(e)    connect.close()try:    if cursor:    # 如果数据表已经存在使用 execute() 方法删除表。    cursor.execute(&quot;DROP TABLE IF EXISTS myapp_users&quot;)    # 创建数据表SQL语句cursor.execute(&quot;&quot;&quot;CREATE TABLE myapp_users (                                 name  CHAR(20) NOT NULL,                                 age  INT(20),                                 phone CHAR(16),                                 addtime timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT )&quot;&quot;&quot;)        connect.commit()  # 提交except Exception as e:    print(e)    connect.rollback()  # 回滚finally:    if cursor:        cursor.close()    if connect:        connect.close()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="数据库插入操作"><a href="#数据库插入操作" class="headerlink" title="数据库插入操作"></a>数据库插入操作</h3><p>对上面的数据表我们可以使用SQL INSERT向myapp_users执行插入操作</p><pre class="line-numbers language-none"><code class="language-none">import MySQLdbconnect &#x3D; None  # 连接对象cursor &#x3D; None  # 游标对象try:    # 连接对象    connect &#x3D; MySQLdb.connect(host&#x3D;&#39;localhost&#39;,  # 主机地址                              user&#x3D;&#39;root&#39;,  # 账号                              password&#x3D;&#39;123456&#39;,  # 密码                              database&#x3D;&#39;mytest&#39;,  # 数据库名                              use_unicode&#x3D;True,                              charset&#x3D;&#39;utf8&#39;)  # 指定字符集    # 游标对象    cursor &#x3D; connect.cursor()  # 通过连接对象调用游标cursor()except Exception as e:    print(e)    connect.close()try:    if cursor:            result &#x3D; cursor.execute(&quot;insert into myapp_users (name, age，phone，addtime) values (&#39;Angle&#39;, 20, 18077445566, 2022-4-21)&quot;)  # 插入操作        connect.commit()  # 提交except Exception as e:    print(e)    connect.rollback()  # 回滚finally:    if cursor:        cursor.close()    if connect:        connect.close()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用这样的代码可以往SQL中传递参数</p><pre class="line-numbers language-none"><code class="language-none">......result &#x3D; cursor.execute(&quot;insert into myapp_users (name, age，phone，addtime) values (%s, %s, %s, %s)&quot; %(name,age,phone,addtime))......<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="数据库查询操作"><a href="#数据库查询操作" class="headerlink" title="数据库查询操作"></a>数据库查询操作</h3><p>Python查询Mysql使用 fetchone() 方法获取单条数据, 使用fetchall() 方法获取多条数据。</p><ul><li><strong>fetchone():</strong> 该方法获取下一个查询结果集。结果集是一个对象</li><li>**fetchall():**接收全部的返回结果行.</li><li><strong>rowcount:</strong> 这是一个只读属性，并返回执行execute()方法后影响的行数。</li></ul><pre class="line-numbers language-none"><code class="language-none">import MySQLdbconnect &#x3D; None  # 连接对象cursor &#x3D; None  # 游标对象try:    # 连接对象    connect &#x3D; MySQLdb.connect(host&#x3D;&#39;localhost&#39;,  # 主机地址                              user&#x3D;&#39;root&#39;,  # 账号                              password&#x3D;&#39;123456&#39;,  # 密码                              database&#x3D;&#39;mytest&#39;,  # 数据库名                              use_unicode&#x3D;True,                              charset&#x3D;&#39;utf8&#39;)  # 指定字符集    # 游标对象    cursor &#x3D; connect.cursor()  # 通过连接对象调用游标cursor()except Exception as e:    print(e)    connect.close()try:    if cursor:            result &#x3D; cursor.execute(&quot;select * from myapp_users where age &gt; %s&quot; %(20))  # 查询年龄大于20的所有数据        one_ressult &#x3D; cursor.fetchone()  # 查询下一条数据        many_result &#x3D; cursor.fetchmany(5)  # 查询下五条数据        all_result &#x3D; cursor.fetchall()  # 查询剩余数据        #可以格式化输出查询结果，用剩余数据all_result 为例        for row in all_result:        name &#x3D; row[0]        age &#x3D; row[1]        phone &#x3D; row[2]        addtime &#x3D; row[3]        print(&quot;name&#x3D;%s,age&#x3D;%s,phone&#x3D;%s,addtime&#x3D;%s&quot; % (name,age,phone,addtime))        connect.commit()  # 提交except Exception as e:    print(e)    connect.rollback()  # 回滚finally:    if cursor:        cursor.close()    if connect:        connect.close()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="数据库更新操作"><a href="#数据库更新操作" class="headerlink" title="数据库更新操作"></a>数据库更新操作</h3><p>更新操作用于更新数据表的的数据，以下实例将 myapp_users表中的 name字段为 ‘Angle’ 的 age字段递增 1：</p><pre class="line-numbers language-none"><code class="language-none">import MySQLdbconnect &#x3D; None  # 连接对象cursor &#x3D; None  # 游标对象try:    # 连接对象    connect &#x3D; MySQLdb.connect(host&#x3D;&#39;localhost&#39;,  # 主机地址                              user&#x3D;&#39;root&#39;,  # 账号                              password&#x3D;&#39;123456&#39;,  # 密码                              database&#x3D;&#39;mytest&#39;,  # 数据库名                              use_unicode&#x3D;True,                              charset&#x3D;&#39;utf8&#39;)  # 指定字符集    # 游标对象    cursor &#x3D; connect.cursor()  # 通过连接对象调用游标cursor()except Exception as e:    print(e)    connect.close()try:    if cursor:            result &#x3D; cursor.execute(&quot;updata myapp_users set age &#x3D; age+1 where name &#x3D;&#39;%s&#39;&quot; %(&quot;Angle&quot;))  # 给Angle字段的age + 1        connect.commit()  # 提交except Exception as e:    print(e)    connect.rollback()  # 回滚finally:    if cursor:        cursor.close()    if connect:        connect.close()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h3><p>删除操作用于删除数据表中的数据，以下实例演示了删除数据表 myapp_users中 age大于 20 的所有数据：</p><pre class="line-numbers language-none"><code class="language-none">import MySQLdbconnect &#x3D; None  # 连接对象cursor &#x3D; None  # 游标对象try:    # 连接对象    connect &#x3D; MySQLdb.connect(host&#x3D;&#39;localhost&#39;,  # 主机地址                              user&#x3D;&#39;root&#39;,  # 账号                              password&#x3D;&#39;123456&#39;,  # 密码                              database&#x3D;&#39;mytest&#39;,  # 数据库名                              use_unicode&#x3D;True,                              charset&#x3D;&#39;utf8&#39;)  # 指定字符集    # 游标对象    cursor &#x3D; connect.cursor()  # 通过连接对象调用游标cursor()except Exception as e:    print(e)    connect.close()try:    if cursor:            result &#x3D; cursor.execute(&quot;delete from myapp_users where age &gt; %s&quot; %(20))  # 给age大于20的做删除操作        connect.commit()  # 提交except Exception as e:    print(e)    connect.rollback()  # 回滚finally:    if cursor:        cursor.close()    if connect:        connect.close()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="事务机制"><a href="#事务机制" class="headerlink" title="事务机制"></a>事务机制</h3><p>事务机制可以确保数据一致性。</p><p>事务应该具有4个属性：原子性、一致性、隔离性、持久性。这四个属性通常称为ACID特性。</p><ul><li>原子性（atomicity）。一个事务是一个不可分割的工作单位，事务中包括的诸操作要么都做，要么都不做。</li><li>一致性（consistency）。事务必须是使数据库从一个一致性状态变到另一个一致性状态。一致性与原子性是密切相关的。</li><li>隔离性（isolation）。一个事务的执行不能被其他事务干扰。即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。</li><li>持久性（durability）。持续性也称永久性（permanence），指一个事务一旦提交，它对数据库中数据的改变就应该是永久性的。接下来的其他操作或故障不应该对其有任何影响。</li></ul><p>Python DB API 2.0 的事务提供了两个方法 commit 或 rollback。</p><h3 id="一些最重要的-SQL-命令"><a href="#一些最重要的-SQL-命令" class="headerlink" title="一些最重要的 SQL 命令"></a>一些最重要的 SQL 命令</h3><ul><li><strong>SELECT</strong> - 从数据库中提取数据</li><li><strong>UPDATE</strong> - 更新数据库中的数据</li><li><strong>DELETE</strong> - 从数据库中删除数据</li><li><strong>INSERT INTO</strong> - 向数据库中插入新数据</li><li><strong>CREATE DATABASE</strong> - 创建新数据库</li><li><strong>ALTER DATABASE</strong> - 修改数据库</li><li><strong>CREATE TABLE</strong> - 创建新表</li><li><strong>ALTER TABLE</strong> - 变更（改变）数据库表</li><li><strong>DROP TABLE</strong> - 删除表</li><li><strong>CREATE INDEX</strong> - 创建索引（搜索键）</li><li><strong>DROP INDEX</strong> - 删除索引</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;什么是MySQLdb&quot;&gt;&lt;a href=&quot;#什么是MySQLdb&quot; class=&quot;headerlink&quot; title=&quot;什么是MySQLdb?&quot;&gt;&lt;/a&gt;什么是MySQLdb?&lt;/h3&gt;&lt;p&gt;MySQLdb 是用于Python链接Mysql数据库的接口，它实现了 </summary>
      
    
    
    
    <category term="Python" scheme="http://huangxiaoruipo.github.io/categories/Python/"/>
    
    
    <category term="Python" scheme="http://huangxiaoruipo.github.io/tags/Python/"/>
    
    <category term="MySQL" scheme="http://huangxiaoruipo.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Hexo框架搭建本地博客步骤（二）</title>
    <link href="http://huangxiaoruipo.github.io/2022/04/19/hexo-kuang-jia-da-jian-ben-di-bo-ke-bu-zou-er/"/>
    <id>http://huangxiaoruipo.github.io/2022/04/19/hexo-kuang-jia-da-jian-ben-di-bo-ke-bu-zou-er/</id>
    <published>2022-04-19T01:54:17.000Z</published>
    <updated>2022-11-05T06:44:43.639Z</updated>
    
    <content type="html"><![CDATA[<h3 id="关于Github的SSH-key获取"><a href="#关于Github的SSH-key获取" class="headerlink" title="关于Github的SSH-key获取"></a>关于Github的SSH-key获取</h3><p>接上一个文章内容，要再本地提交代码需要Github的权限，我们直接使用账户密码的话，并不安全，使用SSH-key可以免密登录，解决服务器-本地连接的问题。</p><ul><li>Git Bash 内输入</li></ul><pre class="line-numbers language-none"><code class="language-none">git config --global user.name &quot;usernmae&quot; &#x2F;&#x2F;你的用户名git config --global user.email  &quot;youremail&quot; &#x2F;&#x2F;你的注册邮箱<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>接着获取密钥</li></ul><pre class="line-numbers language-none"><code class="language-none">ssh-keygen -t rsa -C github邮件地址<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><p>每次提示敲一次回车，GIit Bash出现一个点阵的方框信息就表示成功</p></li><li><p>这个操作会在<code>C:\Users\LENOVO\.ssh</code>生成一个密钥文件，打开<code>id_rsa.pub</code>复制里面的内容</p></li><li><p>在下图所示Github设置里面密钥，保存</p></li><li><img src="/2022/04/19/hexo-kuang-jia-da-jian-ben-di-bo-ke-bu-zou-er/image-20220419114225057.png" alt="image-20220419114225057" style="zoom:67%;"></li><li><p>在Git Bash检测设置是否成功</p></li></ul><pre class="line-numbers language-none"><code class="language-none">ssh -T git@github.com &#x2F;&#x2F;输入这句命令，之后提示yes&#x2F;no的话输入 yes <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>最后有下图提示说明成功</li></ul><p><img src="/2022/04/19/hexo-kuang-jia-da-jian-ben-di-bo-ke-bu-zou-er/image-20220419114606789.png" alt="成功了"></p><h3 id="使用Hexo搭建博客"><a href="#使用Hexo搭建博客" class="headerlink" title="使用Hexo搭建博客"></a>使用Hexo搭建博客</h3><ul><li>在你心仪的地方新建一个用来存放将来博客各种代码文件的文件夹</li><li>进入文件夹，右键在文件夹下打开Git Bash</li><li>初始化Hexo</li></ul><pre class="line-numbers language-none"><code class="language-none">Hexo init MyBlogcd MyBlognpm install<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>执行完毕会生成下方文件夹目录（以下搬运自HEXO<a href="https://hexo.io/zh-cn/docs/setup">官方文档</a>）</li></ul><pre class="line-numbers language-none"><code class="language-none">.├── _config.yml├── package.json├── scaffolds├── source|   ├── _drafts|   └── _posts└── themes<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="config-yml"><a href="#config-yml" class="headerlink" title="_config.yml"></a>_config.yml</h4><ul><li>网站的 <a href="https://hexo.io/zh-cn/docs/configuration">配置</a> 信息，您可以在此配置大部分的参数。</li></ul><h4 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a>package.json</h4><ul><li>应用程序的信息。<a href="https://ejs.co/">EJS</a>, <a href="http://learnboost.github.io/stylus/">Stylus</a> 和 <a href="http://daringfireball.net/projects/markdown/">Markdown</a> renderer 已默认安装，您可以自由移除。</li></ul><pre class="line-numbers language-none"><code class="language-none">package.json&#123;  &quot;name&quot;: &quot;hexo-site&quot;,  &quot;version&quot;: &quot;0.0.0&quot;,  &quot;private&quot;: true,  &quot;hexo&quot;: &#123;    &quot;version&quot;: &quot;&quot;  &#125;,  &quot;dependencies&quot;: &#123;    &quot;hexo&quot;: &quot;^3.8.0&quot;,    &quot;hexo-generator-archive&quot;: &quot;^0.1.5&quot;,    &quot;hexo-generator-category&quot;: &quot;^0.1.3&quot;,    &quot;hexo-generator-index&quot;: &quot;^0.2.1&quot;,    &quot;hexo-generator-tag&quot;: &quot;^0.2.0&quot;,    &quot;hexo-renderer-ejs&quot;: &quot;^0.3.1&quot;,    &quot;hexo-renderer-stylus&quot;: &quot;^0.3.3&quot;,    &quot;hexo-renderer-marked&quot;: &quot;^0.3.2&quot;,    &quot;hexo-server&quot;: &quot;^0.3.3&quot;  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="scaffolds"><a href="#scaffolds" class="headerlink" title="scaffolds"></a>scaffolds</h4><ul><li><p><a href="https://hexo.io/zh-cn/docs/writing">模版</a> 文件夹。当您新建文章时，<code>Hexo </code>会根据 <code>scaffold</code> 来建立文件。</p></li><li><p>Hexo的模板是指在新建的文章文件中默认填充的内容。例如，如果您修改<code>scaffold/post.md</code>中的<code>Front-matter</code>内容，那么每次新建一篇文章时都会包含这个修改。</p></li></ul><h4 id="source"><a href="#source" class="headerlink" title="source"></a>source</h4><ul><li>资源文件夹是存放用户资源的地方。除 <code>_posts</code> 文件夹之外，开头命名为 <code>_</code> (下划线)的文件 &#x2F; 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 <code>public</code> 文件夹，而其他文件会被拷贝过去。</li></ul><h4 id="themes"><a href="#themes" class="headerlink" title="themes"></a>themes</h4><ul><li><a href="https://hexo.io/zh-cn/docs/themes">主题</a> 文件夹。Hexo 会根据主题来生成静态页面。</li></ul><h3 id="让我们来生成第一个Hexo博客站点"><a href="#让我们来生成第一个Hexo博客站点" class="headerlink" title="让我们来生成第一个Hexo博客站点"></a>让我们来生成第一个Hexo博客站点</h3><pre class="line-numbers language-none"><code class="language-none">hexo g &#x2F;&#x2F;hexo generate简写，根据模板，拉取资源文件渲染静态网页hexo s &#x2F;&#x2F;hexo server简写，在本地运行服务<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>在浏览器，本地访问 <a href="http://127.0.0.1:4000/">http://127.0.0.1:4000</a> 端口，如果被占用中断运行服务厚更换到5000端口</li></ul><pre class="line-numbers language-none"><code class="language-none">hexo s -p 5000<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="部署到Github个人主页"><a href="#部署到Github个人主页" class="headerlink" title="部署到Github个人主页"></a>部署到Github个人主页</h3><ul><li>安装Hexo一键部署工具包</li></ul><pre class="line-numbers language-none"><code class="language-none">npm install hexo-deployer-git --save<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>根目录下的<code>_config.yml</code>文件deploy里添加以下设置</li></ul><pre class="line-numbers language-none"><code class="language-none">deploy:  type: git  repo: https:&#x2F;&#x2F;github.com&#x2F;你的用户名&#x2F;你的用户名.github.io &#x2F;&#x2F;即注册仓库的名称  branch: main &#x2F;&#x2F;新版本特性使用Main<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>一切就绪，Git Bash输入以下命令</li></ul><pre class="line-numbers language-none"><code class="language-none">hexo cleanhexo ghexo d &#x2F;&#x2F;将代码托管到Github仓库<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>有可能会需要输入 name password，分别输入注册邮箱和密码即可。</li><li>成功后在浏览器输入网址</li></ul><pre class="line-numbers language-none"><code class="language-none">https:&#x2F;&#x2F;仓库名.github.io&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>如果部署失败可以参考下面解决方法，这是我第一次部署的时候踩到的各种坑。</li></ul><h3 id="关于部署不上的解决方法"><a href="#关于部署不上的解决方法" class="headerlink" title="关于部署不上的解决方法"></a>关于部署不上的解决方法</h3><ul><li>其一，<code>Github</code> 的服务器部署在海外，连接比较慢，多测试几次</li><li>其二，恰好当时网址被墙了，设置以下host再试</li><li>其三，还是登录不上的话再去设置一个<code>Personal access tokens</code>来作为登录密钥</li><li>其四，启用通过 HTTPS 的 SSH 连接，在<code>~/.ssh/config</code>编辑文件，设置如下</li></ul><pre class="line-numbers language-none"><code class="language-none">Host github.comHostname ssh.github.comPort 443User git<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>再次连接github.com测试是否连接上</li></ul><pre class="line-numbers language-none"><code class="language-none">$ ssh -T git@github.com&gt; Hi username! You&#39;ve successfully authenticated, but GitHub does not&gt; provide shell access.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="网站托管成功"><a href="#网站托管成功" class="headerlink" title="网站托管成功"></a>网站托管成功</h3><ul><li>到现在我们的博客就部署完成了，但是自带界面是怎么能满足我们对美的追求呢，下篇会介绍以下怎么使用各位大佬现成的主题对个人博客美化、修改出一个有个人特色的一个网站。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;关于Github的SSH-key获取&quot;&gt;&lt;a href=&quot;#关于Github的SSH-key获取&quot; class=&quot;headerlink&quot; title=&quot;关于Github的SSH-key获取&quot;&gt;&lt;/a&gt;关于Github的SSH-key获取&lt;/h3&gt;&lt;p&gt;接上一个文章</summary>
      
    
    
    
    <category term="HEXO" scheme="http://huangxiaoruipo.github.io/categories/HEXO/"/>
    
    
    <category term="HEXO" scheme="http://huangxiaoruipo.github.io/tags/HEXO/"/>
    
    <category term="Node.js" scheme="http://huangxiaoruipo.github.io/tags/Node-js/"/>
    
    <category term="npm" scheme="http://huangxiaoruipo.github.io/tags/npm/"/>
    
    <category term="Git" scheme="http://huangxiaoruipo.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Hexo框架搭建本地博客步骤（一）</title>
    <link href="http://huangxiaoruipo.github.io/2022/04/16/hexo-kuang-jia-da-jian-ben-di-bo-ke-bu-zou-yi/"/>
    <id>http://huangxiaoruipo.github.io/2022/04/16/hexo-kuang-jia-da-jian-ben-di-bo-ke-bu-zou-yi/</id>
    <published>2022-04-16T15:54:04.000Z</published>
    <updated>2022-11-05T06:44:43.637Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p> 本系列主要是讲怎么去安装 <em>Node.js</em> 、<em>Hexo</em> 、<em>Git</em> 、<em>配置GitHub仓库</em>、以及新建第一个 <em>GitHub Pages</em>页面。</p><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><h3 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a>安装Node.js</h3><ul><li><p>前往<a href="http://nodejs.cn/">Node.js</a>中文网站，根据Windows版本选择合适的安装包，根据中文文档安装Node环境</p></li><li><p>打开一个新的PowerShell窗口,输入下面命令检查是否安装成功</p><pre class="line-numbers language-none"><code class="language-none">npm -vnode -v<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>成功会显示当前安装环境的版本</p></li></ul><h3 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h3><ul><li><p>进入官网下载软件并根据网络教程安装</p></li><li><p>打开一个新的PowerShell窗口,输入下面命令检查是否安装成功</p></li></ul><pre class="line-numbers language-none"><code class="language-none">git --version<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="修改npm源"><a href="#修改npm源" class="headerlink" title="修改npm源"></a>修改npm源</h3><ul><li>由于官方 NPM 源下载 包的速度太慢，所以我们将 NPM 的源 替换成 淘宝源：</li></ul><pre class="line-numbers language-none"><code class="language-none">npm config set registry https:&#x2F;&#x2F;registry.npm.taobao.org<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h3><ul><li>Git-bash输入</li></ul><pre class="line-numbers language-none"><code class="language-none">npm install hexo-cli -g<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><a href="https://hexo.io/zh-cn/docs/">也可以参考官方文档</a>配置</li></ul><h3 id="配置GitHub仓库"><a href="#配置GitHub仓库" class="headerlink" title="配置GitHub仓库"></a>配置GitHub仓库</h3><ul><li><p>注册一个GitHub账号，创建一个仓库用来托管代码</p></li><li><p><img src="/2022/04/16/hexo-kuang-jia-da-jian-ben-di-bo-ke-bu-zou-yi/image-20220416223415359.png"></p></li><li><p><img src="/2022/04/16/hexo-kuang-jia-da-jian-ben-di-bo-ke-bu-zou-yi/image-20220416223551516.png"></p></li></ul><h2 id="环境搭建完成"><a href="#环境搭建完成" class="headerlink" title="环境搭建完成"></a>环境搭建完成</h2><p>到这里，除了GitHub的SSH Key 配置已经基本完成了，优秀的教程很多可以参考网上的教程，今天很晚了，明天继续写SSH Key 配置。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;&lt;p&gt; 本系列主要是讲怎么去安装 &lt;em&gt;Node.js&lt;/em&gt; 、&lt;em&gt;Hexo&lt;/em&gt; 、&lt;em&gt;Git&lt;/em&gt; 、&lt;</summary>
      
    
    
    
    <category term="HEXO" scheme="http://huangxiaoruipo.github.io/categories/HEXO/"/>
    
    
    <category term="HEXO" scheme="http://huangxiaoruipo.github.io/tags/HEXO/"/>
    
    <category term="Node.js" scheme="http://huangxiaoruipo.github.io/tags/Node-js/"/>
    
    <category term="npm" scheme="http://huangxiaoruipo.github.io/tags/npm/"/>
    
    <category term="Git" scheme="http://huangxiaoruipo.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>我的第一个博客</title>
    <link href="http://huangxiaoruipo.github.io/2022/04/15/wo-de-di-yi-ge-bo-ke/"/>
    <id>http://huangxiaoruipo.github.io/2022/04/15/wo-de-di-yi-ge-bo-ke/</id>
    <published>2022-04-15T09:04:41.000Z</published>
    <updated>2022-11-05T06:44:43.650Z</updated>
    
    <content type="html"><![CDATA[<h3 id="为什么要做自己的博客呢？"><a href="#为什么要做自己的博客呢？" class="headerlink" title="为什么要做自己的博客呢？"></a>为什么要做自己的博客呢？</h3><p>最根本的原因是林檎大佬说做一个个人博客网站非常有用，记录自己的学习心得、有用的代码块、时间长了也是个人简历说明的一种。正好本人对写作也充满兴趣，平时忙于工作又没时间去写点东西，趁着这个机会也把想做的事情做出来吧。</p><h3 id="选用什么方式去部署个人博客？"><a href="#选用什么方式去部署个人博客？" class="headerlink" title="选用什么方式去部署个人博客？"></a>选用什么方式去部署个人博客？</h3><p>一开始考虑的是仿照优秀的博客，使用原生代码去写自己的博客网站，在搭建网站的过程中去学习前端的技术。不过在做了两天的准备后，发现一个完善的博客框架和好看的前端页面是我目前做不出来的，大受打击。最终选择使用了<a href="https://hexo.io/zh-cn/">Hexo</a>+<a href="https://github.com/">GitHub</a>来部署个人网站。</p><p>Hexo正如它所说的一样是如此的快速、高效、简洁。基于Node.js的优点，Hexo很快的将本地Markdown页面渲染成网页，另外有大量的插件可以使用，支持一键部署；当然，最重要的还是它的主题很多，使用起来很方便，只需要根据说明文档修改就能制作出来一具有个人特色的个人博客。</p><h3 id="成果及感悟"><a href="#成果及感悟" class="headerlink" title="成果及感悟"></a>成果及感悟</h3><p>搭建个人博客的过程中遇到了各种奇奇怪怪的问题，把人折腾的够呛，不过在经历了一天的不懈努力，大体的框架终于搭建出来了！！！！撒花~！</p><p>本博客使用到的资源环境如下：</p><ul><li>操作系统：Windows 10</li><li>Node,js</li><li>Hexo</li><li>Git</li><li>一个GitHub账号</li></ul><p>成品展示~</p><p><img src="/2022/04/15/wo-de-di-yi-ge-bo-ke/image-20220416212749962.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;为什么要做自己的博客呢？&quot;&gt;&lt;a href=&quot;#为什么要做自己的博客呢？&quot; class=&quot;headerlink&quot; title=&quot;为什么要做自己的博客呢？&quot;&gt;&lt;/a&gt;为什么要做自己的博客呢？&lt;/h3&gt;&lt;p&gt;最根本的原因是林檎大佬说做一个个人博客网站非常有用，记录自己</summary>
      
    
    
    
    <category term="HEXO" scheme="http://huangxiaoruipo.github.io/categories/HEXO/"/>
    
    
    <category term="HEXO" scheme="http://huangxiaoruipo.github.io/tags/HEXO/"/>
    
    <category term="matery" scheme="http://huangxiaoruipo.github.io/tags/matery/"/>
    
  </entry>
  
</feed>
